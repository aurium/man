<!DOCTYPE HTML>
<html lang="zh_CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>凹语言手册</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="凹语言手册">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">凹语言手册</a></li><li class="chapter-item expanded affix "><a href="preface.html">前言</a></li><li class="chapter-item expanded "><a href="chs/1.安装及入门/index.html"><strong aria-hidden="true">1.</strong> 安装及入门</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chs/1.安装及入门/1.1.你好凹语言.html"><strong aria-hidden="true">1.1.</strong> 你好，凹语言</a></li><li class="chapter-item expanded "><a href="chs/1.安装及入门/1.2.安装凹语言.html"><strong aria-hidden="true">1.2.</strong> 安装凹语言</a></li><li class="chapter-item expanded "><a href="chs/1.安装及入门/1.3.命令行功能.html"><strong aria-hidden="true">1.3.</strong> 命令行功能</a></li><li class="chapter-item expanded "><a href="chs/1.安装及入门/1.4.工程目录结构.html"><strong aria-hidden="true">1.4.</strong> 工程目录结构</a></li><li class="chapter-item expanded "><a href="chs/1.安装及入门/1.5.IDE插件.html"><strong aria-hidden="true">1.5.</strong> IDE插件</a></li></ol></li><li class="chapter-item expanded "><a href="chs/2.程序结构/index.html"><strong aria-hidden="true">2.</strong> 程序结构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chs/2.程序结构/2.1.全局声明.html"><strong aria-hidden="true">2.1.</strong> 全局声明</a></li><li class="chapter-item expanded "><a href="chs/2.程序结构/2.2.全局变量声明.html"><strong aria-hidden="true">2.2.</strong> 全局变量声明</a></li><li class="chapter-item expanded "><a href="chs/2.程序结构/2.3.函数声明.html"><strong aria-hidden="true">2.3.</strong> 函数声明</a></li><li class="chapter-item expanded "><a href="chs/2.程序结构/2.4.常量声明.html"><strong aria-hidden="true">2.4.</strong> 常量声明</a></li><li class="chapter-item expanded "><a href="chs/2.程序结构/2.5.导入声明.html"><strong aria-hidden="true">2.5.</strong> 导入声明</a></li></ol></li><li class="chapter-item expanded "><a href="chs/3.基础数据类型/index.html"><strong aria-hidden="true">3.</strong> 基础数据类型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chs/3.基础数据类型/3.1.局部变量声明.html"><strong aria-hidden="true">3.1.</strong> 局部变量声明</a></li><li class="chapter-item expanded "><a href="chs/3.基础数据类型/3.2.整数.html"><strong aria-hidden="true">3.2.</strong> 整数</a></li><li class="chapter-item expanded "><a href="chs/3.基础数据类型/3.3.浮点数.html"><strong aria-hidden="true">3.3.</strong> 浮点数</a></li><li class="chapter-item expanded "><a href="chs/3.基础数据类型/3.4.字符串.html"><strong aria-hidden="true">3.4.</strong> 字符串</a></li></ol></li><li class="chapter-item expanded "><a href="chs/4.函数/index.html"><strong aria-hidden="true">4.</strong> 函数</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chs/4.函数/4.1.函数调用.html"><strong aria-hidden="true">4.1.</strong> 函数调用</a></li><li class="chapter-item expanded "><a href="chs/4.函数/4.2.函数值.html"><strong aria-hidden="true">4.2.</strong> 函数值</a></li><li class="chapter-item expanded "><a href="chs/4.函数/4.3.匿名函数及闭包.html"><strong aria-hidden="true">4.3.</strong> 匿名函数及闭包</a></li><li class="chapter-item expanded "><a href="chs/4.函数/4.4.条件语句.html"><strong aria-hidden="true">4.4.</strong> 条件语句</a></li><li class="chapter-item expanded "><a href="chs/4.函数/4.5.循环语句.html"><strong aria-hidden="true">4.5.</strong> 循环语句</a></li><li class="chapter-item expanded "><a href="chs/4.函数/4.6.分支语句.html"><strong aria-hidden="true">4.6.</strong> 分支语句</a></li></ol></li><li class="chapter-item expanded "><a href="chs/5.复合数据类型/index.html"><strong aria-hidden="true">5.</strong> 复合数据类型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chs/5.复合数据类型/5.1.引用.html"><strong aria-hidden="true">5.1.</strong> 引用</a></li><li class="chapter-item expanded "><a href="chs/5.复合数据类型/5.2.数组.html"><strong aria-hidden="true">5.2.</strong> 数组</a></li><li class="chapter-item expanded "><a href="chs/5.复合数据类型/5.3.切片.html"><strong aria-hidden="true">5.3.</strong> 切片</a></li></ol></li><li class="chapter-item expanded "><a href="chs/6.自定义类型/index.html"><strong aria-hidden="true">6.</strong> 自定义类型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chs/6.自定义类型/6.1.结构体.html"><strong aria-hidden="true">6.1.</strong> 结构体</a></li><li class="chapter-item expanded "><a href="chs/6.自定义类型/6.2.方法.html"><strong aria-hidden="true">6.2.</strong> 方法</a></li><li class="chapter-item expanded "><a href="chs/6.自定义类型/6.3.方法值.html"><strong aria-hidden="true">6.3.</strong> 方法值</a></li><li class="chapter-item expanded "><a href="chs/6.自定义类型/6.4.嵌入结构体.html"><strong aria-hidden="true">6.4.</strong> 嵌入结构体</a></li><li class="chapter-item expanded "><a href="chs/6.自定义类型/6.5.匿名结构体.html"><strong aria-hidden="true">6.5.</strong> 匿名结构体</a></li></ol></li><li class="chapter-item expanded "><a href="chs/7.接口/index.html"><strong aria-hidden="true">7.</strong> 接口</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chs/7.接口/7.1.空接口-万能封包器.html"><strong aria-hidden="true">7.1.</strong> 空接口-万能封包器</a></li><li class="chapter-item expanded "><a href="chs/7.接口/7.2.非空接口.html"><strong aria-hidden="true">7.2.</strong> 非空接口</a></li><li class="chapter-item expanded "><a href="chs/7.接口/7.3.类型断言总结.html"><strong aria-hidden="true">7.3.</strong> 类型断言总结</a></li><li class="chapter-item expanded "><a href="chs/7.接口/7.4.接口的其它特性.html"><strong aria-hidden="true">7.4.</strong> 接口的其它特性</a></li></ol></li><li class="chapter-item expanded "><a href="chs/9.附录/index.html"><strong aria-hidden="true">8.</strong> 附录</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chs/9.附录/a-spec.html"><strong aria-hidden="true">8.1.</strong> 语言规范</a></li><li class="chapter-item expanded "><a href="chs/9.附录/b-std.html"><strong aria-hidden="true">8.2.</strong> 标准库</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">凹语言手册</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://gitee.com/wa-lang/wa" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><img src="cover.png" alt="" /></p>
<ul>
<li>在线地址：<a href="https://wa-lang.org/man/">https://wa-lang.org/man/</a></li>
<li>社区共建：<a href="https://zh-lang.osanswer.net/t/topic/247">凹语言 MVP 文档共建邀请</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="前言"><a class="header" href="#前言">前言</a></h1>
<p>MVP 是 “Minimum Viable Product” 的首字母缩写，即“最小可用产品”。我们希望发布 MVP 版本让更多的凹语言爱好者可以进行跟多的尝试和探索。感谢中国编程语言爱好者的支持，凹语言 MVP 版本是一个新的起点，欢迎大家参与共建！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-安装及入门"><a class="header" href="#1-安装及入门">1. 安装及入门</a></h1>
<p>本章讲述了最简单的凹语言例子、如何安装凹语言程序、凹语言IDE插件、凹语言工程目录结构和命令行功能等内容。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="11-你好凹语言"><a class="header" href="#11-你好凹语言">1.1. 你好，凹语言</a></h2>
<p>打印“hello world”是C语言之后的惯用案例，凹语言例子打印的是中文“你好，凹语言！”。</p>
<h3 id="111-你好凹语言"><a class="header" href="#111-你好凹语言">1.1.1 你好，凹语言！</a></h3>
<p>创建 hello.wa 文件，内容如下：</p>
<pre><code class="language-wa">// 版权 @2019 凹语言 作者。保留所有权利。

import &quot;fmt&quot;
import &quot;runtime&quot;

global year: i32 = 2023

func main {
    println(&quot;你好，凹语言！&quot;, runtime.WAOS)
    println(add(40, 2), year)

    fmt.Println(&quot;1+1 =&quot;, 1+1)
}

func add(a: i32, b: i32) =&gt; i32 {
    return a+b
}
</code></pre>
<p>其中<code>//</code>开始的是行注释，<code>import</code>关键字导入了2个包准库的包，<code>global</code>关键字定义了一个全局变量，并给了2023的初始值。<code>func</code>关键字定义了<code>main</code>函数和<code>add</code>函数。<code>main</code>函数是程序的入口，其中通过内置的<code>println</code>函数打印了“你好，凹语言！”，同时使用<code>fmt</code>包的<code>Println</code>字符串和整数表达式的结果。在<code>main</code>函数还使用了全局的<code>year</code>变量，此外还调用了<code>add</code>函数并打印了返回值。<code>add</code>函数有2个输入参数和一个返回值。</p>
<p>如果在本地已经安装有凹语言的<code>wa</code>命令（安装方式参考1.2节），可以输入以下命令执行：</p>
<pre><code>$ wa run hello.wa 
你好，凹语言！ wasi
42
1+1 = 2
</code></pre>
<h3 id="112-在线的-playground"><a class="header" href="#112-在线的-playground">1.1.2 在线的 Playground</a></h3>
<p>凹语言是面向 WebAssembly 设计的通用编程语言，从诞生起就将浏览器作为第一支持目标。可以通过 <a href="https://wa-lang.org/playground">https://wa-lang.org/playground</a> 访问 Playground，界面如下：</p>
<p><img src="chs/1.%E5%AE%89%E8%A3%85%E5%8F%8A%E5%85%A5%E9%97%A8/./images/playground-01.png" alt="" /></p>
<p>点击“RUN”按钮，可以看到输出结果。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="12-安装凹语言"><a class="header" href="#12-安装凹语言">1.2. 安装凹语言</a></h2>
<p>除了访问在线的凹语言 Playground，也可以在本地安装凹语言。</p>
<h3 id="121-二进制安装"><a class="header" href="#121-二进制安装">1.2.1 二进制安装</a></h3>
<p>从 Github 下载最新的二进制文件：https://github.com/wa-lang/wa/releases 。需要确保和本地平台对应，比如 v0.8.1 对应 macOS/amd64 平台下载的是 wa_0.8.1_darwin_amd64.tar.gz。</p>
<p>解压后目录内容如下：</p>
<pre><code>$ tree ./wa_0.8.1_darwin_amd64
./wa_0.8.1_darwin_amd64
├── LICENSE
├── README-zh.md
├── README.md
└── wa

1 directory, 5 files
</code></pre>
<p>将该目录路径添加到系统的 <code>PATH</code> 环境，然后重新打开命令行环境执行 <code>wa -v</code> 命令查看版本信息。</p>
<pre><code>$ wa -v
Wa version v0.8.1
</code></pre>
<p>第一次执行 <code>wa</code> 命令时会在命令同一个目录下生成一个 <code>wa.wat2wasm.exe</code> 命令。</p>
<p>到此安装工作完成。</p>
<h3 id="122-从源码安装"><a class="header" href="#122-从源码安装">1.2.2 从源码安装</a></h3>
<p>本地要求安装 Go1.17+ 版本，然后执行以下命令安装最新的 <code>wa</code> 命令：</p>
<pre><code>go install wa-lang.org/wa
</code></pre>
<p>默认会安装到 <code>$HOME/go/bin</code> 目录，因此需要将该该目录路径添加到系统的 <code>PATH</code> 环境。
然后重新打开命令行环境执行一次 <code>wa</code> 命令会输出以上相同的帮助信息。</p>
<p>第一次执行 <code>wa -v</code> 命令查看版本信息时会在命令同一个目录下生成一个 <code>wa.wat2wasm.exe</code> 命令。</p>
<p>到此安装工作完成。</p>
<h3 id="123-homebrew-macos--linux"><a class="header" href="#123-homebrew-macos--linux">1.2.3 Homebrew (MacOS &amp; Linux)</a></h3>
<p>对于 macOS 和 Linux 系统也可以通过 Homebrew 安装：</p>
<pre><code>brew install wa-lang/tap/wa
</code></pre>
<h3 id="124-scoop-windows"><a class="header" href="#124-scoop-windows">1.2.4 Scoop (Windows)</a></h3>
<p>对于 Windows 系统也可以通过 Scoop 安装：</p>
<pre><code>scoop bucket add wa-lang https://github.com/wa-lang/scoop-bucket.git
scoop install wa-lang/wa
</code></pre>
<h3 id="125-本地-playground"><a class="header" href="#125-本地-playground">1.2.5 本地 Playground</a></h3>
<p>安装成功之后，在命令行输入 <code>wa play</code> 可以打开本地 Playground。程序会默认打开浏览器页面，也可以输入 <a href="http://localhost:2023/">http://localhost:2023/</a> 地址访问。效果如下：</p>
<p><img src="chs/1.%E5%AE%89%E8%A3%85%E5%8F%8A%E5%85%A5%E9%97%A8/./images/playground-local-01.png" alt="" /></p>
<p>点击“执行”按钮，可以看到输出结果。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="13-命令行功能"><a class="header" href="#13-命令行功能">1.3. 命令行功能</a></h2>
<p>本节介绍 <code>wa</code> 命令主要功能。</p>
<h3 id="131-帮助信息"><a class="header" href="#131-帮助信息">1.3.1. 帮助信息</a></h3>
<p>输入 <code>wa</code> 命令或 <code>wa -h</code> 可查看命令行帮助信息，如下：</p>
<pre><code>$ wa
NAME:
   Wa - Wa is a tool for managing Wa source code.

USAGE:
   wa [global options] command [command options] [arguments...]

VERSION:
   v0.8.1-mvp

COMMANDS:
   play   start Wa playground
   init   init a sketch Wa module
   build  compile Wa source code
   run    compile and run Wa program
   fmt    format Wa source code file
   test   test Wa packages
   yacc   generates parsers for LALR(1) grammars
   logo   print Wa text format logo

GLOBAL OPTIONS:
   --debug, -d              set debug mode (default: false)
   --trace value, -t value  set trace mode (*|app|compiler|loader)
   --help, -h               show help (default: false)
   --version, -v            print the version (default: false)

COPYRIGHT:
   Copyright 2018 The Wa Authors. All rights reserved.

See &quot;https://wa-lang.org&quot; for more information.
</code></pre>
<p>主要有以下子命令：</p>
<ul>
<li>play：启动本地版本的 playground；</li>
<li>init：初始化一个凹语言工程；</li>
<li>build：编译凹语言程序；</li>
<li>run：编译并执行凹语言程序；</li>
<li>fmt：格式化凹语言源代码文件；</li>
<li>test：执行凹语言工程的单元测试；</li>
<li>yacc：凹语言版本的 yacc，用于生成 LALR(1) 语法规则的解析器代码；</li>
<li>logo：打印凹语言文字版本的Logo。</li>
</ul>
<p>其中 build 命令在 1.1.1 节展示过，play 命令已经在 1.2.5 节展示过，本节简要介绍之外的子命令。</p>
<h3 id="132-初始化工程"><a class="header" href="#132-初始化工程">1.3.2 初始化工程</a></h3>
<p>在 1.1.1 节已经展示过 <code>wa run hello.wa</code> 执行一个独立文件的凹语言程序。但是单文件的凹语言程序有一个巨大的限制——它只有一个文件且不能引用非标准库的代码。对于更大的凹程序推荐用凹工程的方式组织。</p>
<p>使用 <code>wa init</code> 命令可以初始化一个凹工程，先看看命令行帮助：</p>
<pre><code>$ wa init -h
NAME:
   wa init - init a sketch Wa module

USAGE:
   wa init [command options] [arguments...]

OPTIONS:
   --name value, -n value     set app name (default: &quot;hello&quot;)
   --pkgpath value, -p value  set pkgpath file (default: &quot;myapp&quot;)
   --update, -u               update example (default: false)
   --help, -h                 show help (default: false)
</code></pre>
<p>该命令有 <code>-name</code> 和 <code>-pkgpath</code> 两个重要的参数，分别对应工程的名字和对应的包路径。每个参数都有默认值，可以用 <code>wa init</code> 生成一个 hello 工程。</p>
<pre><code>$ wa init
$ tree hello
hello
├── LICENSE
├── README.md
├── src
│   ├── main.wa
│   ├── mymath
│   │   └── math.wa
│   ├── mypkg
│   │   └── pkg.wa
│   └── zz_test.wa
├── vendor
│   └── 3rdparty
│       └── pkg
│           └── pkg.wa
└── wa.mod

7 directories, 8 files
</code></pre>
<p>工程的结构在 1.4 节介绍。</p>
<h3 id="133-编译和执行"><a class="header" href="#133-编译和执行">1.3.3 编译和执行</a></h3>
<p>命令行环境进入 hello 目录，输入 <code>wa build</code> 将在 output 目录构建出 wasm 模块：</p>
<pre><code>$ wa build
$ tree output/
output/
├── hello.wasm
└── hello.wat

1 directory, 2 files
</code></pre>
<p>默认输出的是 WASI 规范的 <code>output/hello.wat</code> 和 <code>output/hello.wasm</code> 文件。可以用标准的工具执行输出的 wasm 模块。也可以用 <code>wa</code> 命令执行：</p>
<pre><code>$ wa run ./output/hello.wasm
你好，凹语言！
5050
...
</code></pre>
<p>如果不带参赛执行 <code>wa run</code> 命令，表示编译并执行当前凹语言工程，会先构建出 <code>output/hello.wasm</code> 然后再执行。</p>
<h3 id="134-格式化代码"><a class="header" href="#134-格式化代码">1.3.4 格式化代码</a></h3>
<p><code>wa fmt</code> 命令用于格式化代码，其命令行帮助信息如下：</p>
<pre><code>$ wa fmt -h
NAME:
   wa fmt - format Wa source code file

USAGE:
   wa fmt [command options] [&lt;file.wa&gt;|&lt;path&gt;|&lt;path&gt;/...]

OPTIONS:
   --help, -h  show help (default: false)
</code></pre>
<p>命令行参数是要进行格式化的路径：</p>
<ul>
<li><code>wa fmt faile.wa</code> 格式化指定的凹语言文件</li>
<li><code>wa fmt path</code> 格式化指定目录下的全部凹语言文件</li>
<li><code>wa fmt path/...</code> 递归格式化指定路径的凹语言文件，含子目录</li>
</ul>
<p>如果不指定参数，则默认格式化当前目录下全部的凹语言文件。如果当前目录属于凹语言工程中，则默认格式化全部子目录的凹语言文件。</p>
<h3 id="135-单元测试"><a class="header" href="#135-单元测试">1.3.5 单元测试</a></h3>
<p>默认生成的工程会有一个 <code>src/zz_test.wa</code> 测试文件，内容如下：</p>
<pre><code class="language-wa">func TestSum {
    assert(sum(100) == 5050, &quot;sum(100) failed&quot;)
}

func ExampleSum {
    println(sum(100))

    // Output:
    // 5050
}
</code></pre>
<p>在 <code>TestSum</code> 测试函数中通过内置的 <code>assert</code> 函数测试 <code>sum(100)</code> 的结果为 5050。在 <code>ExampleSum</code> 示例测试函数中通过 <code>// Output:</code> 测试输出的内容符合期望的结果。</p>
<p>在工程目录的命令行环境通过 <code>wa test</code> 命令执行测试：</p>
<pre><code>$ wa test
ok   myapp 104ms
</code></pre>
<h3 id="136-凹语言版本的-yacc"><a class="header" href="#136-凹语言版本的-yacc">1.3.6 凹语言版本的 yacc</a></h3>
<p>yacc 是用于生成语法解析器的程序，是编译器爱好者的工具。凹语言的 yacc 从 goyacc 移植而来，详细的用法可以参考凹语言官网碎碎念部分的相关文章。</p>
<h3 id="137-打印-logo"><a class="header" href="#137-打印-logo">1.3.7 打印 Logo</a></h3>
<p><code>wa logo</code> 可以输出一些文本格式的 Logo 图案，读者可以通过 <code>wa logo -h</code> 命令帮助自行探索。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="14-工程目录结构"><a class="header" href="#14-工程目录结构">1.4. 工程目录结构</a></h2>
<p>工程目录结构是整个外围工具工作的基础，比如 init 根据该结构生成工程、包管理工具则依次管理依赖关系。</p>
<h3 id="141-工程目录结构简介"><a class="header" href="#141-工程目录结构简介">1.4.1 工程目录结构简介</a></h3>
<p>凹语言程序以包来组织代码，包可以是一个单文件，包也可以是一个目录。凹语言自带的 <code>waroot/examples/hello</code> 案例的是一个更为完整的工程，其目录结构如下：</p>
<pre><code>examples/hello/
├── LICENSE
├── README.md
├── src
│   ├── main.wa
│   └── mymath
│       └── math.wa
├── vendor
│   └── 3rdparty
│       └── pkg
│           └── pkg.wa
└── wa.mod
</code></pre>
<p>除了版权文件、说明文件外，最重要的是 <code>wa.mod</code> 包工程文件，其定义了当前应用的包路径。此外 src 目录下的是当前包路径下的代码，是默认的 main 入口包。</p>
<p><code>wa.mod</code> 文件内容如下：</p>
<pre><code class="language-ini">name = &quot;hello&quot;
pkgpath = &quot;myapp&quot;
version = &quot;0.0.1&quot;
</code></pre>
<p>其中 pkgpath 表示当前包的路径，从而可以推导出 mymath 子目录对应的包路径为 <code>&quot;myapp/mymath&quot;</code>。vendor 目录是依赖的第三方代码，其中 <code>vendor/3rdparty/pkg</code> 对应的包路径为 <code>&quot;3rdparty/pkg&quot;</code>。</p>
<h3 id="142-包管理工具"><a class="header" href="#142-包管理工具">1.4.2 包管理工具</a></h3>
<p>凹语言目前还没有包管理工具，如果依赖第三方包则需要手工同步 vendor 目录。开发组希望在 MVP 版本后启动包管理工具开放工作。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="15-ide插件"><a class="header" href="#15-ide插件">1.5. IDE插件</a></h2>
<p>现代化的编程语言一般都会为各种IDE和编辑器提供扩展，以提高编程的体验。凹语言为 VS Code、Fleet 和 Vim 提供了基本插件支持。</p>
<h3 id="151-vs-code-插件"><a class="header" href="#151-vs-code-插件">1.5.1 VS Code 插件</a></h3>
<p>在 VS Code 扩展商店检索 “wa” 即可以查到凹语言插件。安装之后会有基本的语法高亮等功能。</p>
<p>VS Code 效果如下：</p>
<p><img src="chs/1.%E5%AE%89%E8%A3%85%E5%8F%8A%E5%85%A5%E9%97%A8/./images/vscode.png" alt="" /></p>
<h3 id="152-fleet-插件"><a class="header" href="#152-fleet-插件">1.5.2 Fleet 插件</a></h3>
<p>Fleet 插件仓库：<a href="https://github.com/wa-lang/fleet-wa">https://github.com/wa-lang/fleet-wa</a></p>
<p>根据仓库提示安装，效果如下：</p>
<p><img src="chs/1.%E5%AE%89%E8%A3%85%E5%8F%8A%E5%85%A5%E9%97%A8/./images/fleet-wa-screenshot.png" alt="" /></p>
<h3 id="153-vim-插件"><a class="header" href="#153-vim-插件">1.5.3 Vim 插件</a></h3>
<p>Vim 插件仓库：<a href="https://github.com/wa-lang/vim-wa">https://github.com/wa-lang/vim-wa</a></p>
<p>根据仓库提示安装，效果如下：</p>
<p><img src="chs/1.%E5%AE%89%E8%A3%85%E5%8F%8A%E5%85%A5%E9%97%A8/./images/vim-wa-screenshot.png" alt="" /></p>
<blockquote>
<p>在编写文档过程中突然得知 Vim 的作者 Bram Moolenaar 去世，谨以此插件祝愿 Vim 永垂不朽！</p>
</blockquote>
<h3 id="154-其他编辑器"><a class="header" href="#154-其他编辑器">1.5.4 其他编辑器</a></h3>
<p>MVP 之后凹语言的语法已经基本固定，希望社区可以参与其他编辑器支持共建。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-程序结构"><a class="header" href="#2-程序结构">2. 程序结构</a></h1>
<p>凹语言和其他编程语言一样，一个大的程序是由很多小的部分组成的。本章介绍全局变量声明、函数声明、常量声明、导入声明和类型声明。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="21-全局声明"><a class="header" href="#21-全局声明">2.1. 全局声明</a></h2>
<p>一个典型的 凹语言 程序源码如下例所示：</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

import &quot;errors&quot;

const PI = 3.1415926

global 终极问题的答案: i32

func main {
    终极问题的答案 = getAnswer()
    println(&quot;宇宙的答案：&quot;, 终极问题的答案)
    println(&quot;π:&quot;, PI)

    err := errors.New(&quot;!!!&quot;)
    println(&quot;err:&quot;, err.Error())
}

func getAnswer =&gt; i32 {
    return 42
}
</code></pre>
<blockquote>
<p>与很多语言类似，在 凹语言 中，双斜杠 <code>//</code> 后至行尾的部分为注释，不产生实际作用。</p>
</blockquote>
<p>凹代码由<code>全局声明</code>组成，比如在上面的例子中：</p>
<ul>
<li><code>import &quot;errors&quot;</code> 是一个导入 <code>errors</code> 模块的声明</li>
<li><code>const PI = 3.1415926</code> 是一个常量声明，它声明了一个名为 <code>PI</code> 的常量，值为 3.1415926</li>
<li><code>global 终极问题的答案: i32</code> 是一个全局变量声明，它声明了一个名为 <code>终极问题的答案</code> 的全局变量，类型为32位整数</li>
<li><code>func getAnswer =&gt; i32 {...}</code> 是一个函数声明，它声明了一个返回值为32位整数的函数</li>
</ul>
<p>凹语言 共有5种全局声明，每种声明均由特定的关键字开始（其后跟随该声明对象的实体），声明及对应关键字的关系如下：</p>
<ul>
<li><code>global</code> ：全局变量声明</li>
<li><code>func</code> ：函数声明</li>
<li><code>const</code> ：常量声明</li>
<li><code>import</code> ：导入声明</li>
<li><code>type</code> ：类型声明</li>
</ul>
<p>本章接下来的小节将依次简介全局变量声明、函数声明、常量声明、导入声明，类型声明将在第6章单独讲解。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="22-全局变量声明"><a class="header" href="#22-全局变量声明">2.2. 全局变量声明</a></h2>
<p>全局变量声明以关键字 <code>global</code> 开始，一般语法如下：</p>
<pre><code class="language-wa">global 变量名: 类型 = 初始值表达式
</code></pre>
<p>比如下面的例子：</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

global aInt: i32 = 42     // 32位有符号整数
global _num: f32 = 952.7  // 32位浮点数

func main {
    println(aInt)
    println(_num)
    println(名字)
    println(counter)
}

global 名字: string = &quot;张三&quot; // 字符串
global counter: u32         // 32位无符号整数
</code></pre>
<p>该程序运行的输出如下：</p>
<pre><code>42
952.7
张三
0
</code></pre>
<p>全局变量在模块内部的任何地方都可以使用——哪怕全局变量的声明与使用位于不同的源文件中，只要它们位于同一个模块内即可；在同一个源文件内，也并不要求“先声明再使用”，上面的例子中，变量 <code>名字</code>、<code>counter</code> 就可体现该特点。</p>
<p>需要注意的是，上例中变量 <code>counter</code> 声明时没有给出初始值：</p>
<blockquote>
<p>在 凹语言 中，未给定初始值的变量一概以0值初始化，这有助于消除不确定性。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="23-函数声明"><a class="header" href="#23-函数声明">2.3. 函数声明</a></h2>
<p>函数声明以关键字 <code>func</code> 开始，一般语法如下：</p>
<pre><code class="language-wa">func 函数名(参数列表) =&gt; (返回值列表) {函数体}
</code></pre>
<p>比如下面的例子：</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

func swap(i, j: i32) =&gt; (i32, i32) {
    return j, i
}

func main {
    a, b := swap(4, 2)
    println(&quot;a:&quot;, a, &quot;, b:&quot;, b)
    println(add(a, b))
}

func add(i, j: i32) =&gt; i32 {
    return i + j
}
</code></pre>
<p>该程序运行的输出如下：</p>
<pre><code>a: 2 , b: 4
6
</code></pre>
<p>对于没有返回值的函数，<code>=&gt; (返回值列表)</code> 的部分可省略，没有输入参数的函数 <code>(参数列表)</code> 的部分可省略，比如上例中的：<code>func main {...}</code>，即为：<code>func main() =&gt; () {...}</code> 的简写。</p>
<p>与全局变量类似，函数可在包内的任何源文件中声明且无需“先声明再使用”。</p>
<p>关于函数的更多信息见第4章。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="24-常量声明"><a class="header" href="#24-常量声明">2.4. 常量声明</a></h2>
<p>常量声明以关键字 <code>const</code> 开始，一般语法如下：</p>
<pre><code class="language-wa">const 常量名: 类型 = 常量值
</code></pre>
<p>比如下面的例子：</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

const Answer: i32 = 42
const aConstString: string = &quot;你好，凹语言&quot;

func main {
    println(Answer)
    println(aConstString)
    println(aConstInt)
}

const aConstInt = 13
</code></pre>
<p>该程序运行的输出如下：</p>
<pre><code>42
你好，凹语言
13
</code></pre>
<p>声明常量时，如果不指定类型（比如上例中的 <code>aConstInt</code>），那么它将是<strong>无类型常量</strong>，无类型常量有4种类型，分别为：无类型整数、无类型浮点数、无类型字符、无类型字符串，常量值写法如下：</p>
<pre><code class="language-wa">const aUntypedInt = 11       // 无类型整数
const aUntypedFloat = 13.0   // 无类型浮点数
const aUntypedRune = 'a'     // 无类型字符
const aUntypedString = &quot;abc&quot; // 无类型字符串
</code></pre>
<p>对常量值的算数逻辑运算是在编译时完成的，比如：</p>
<pre><code class="language-wa">// 版权 @2019 凹语言 作者。保留所有权利。

const K = 4200000000000000000000000
const J = 4200000000000000000000000

func main {
    println(K/J)
}
</code></pre>
<p>虽然<code>K</code>和<code>J</code>的值均超过了凹中位数最多的整数类型<code>i64</code>的表达范围，但是<code>K/J</code>的值仍然能被正确打印。这也侧面体现了<strong>数值常量拥有超过变量基本类型的表达范围和精度</strong>。</p>
<p>将常量赋值给变量时的相关规则，将在第3章详细讨论。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="25-导入声明"><a class="header" href="#25-导入声明">2.5. 导入声明</a></h2>
<p>导入声明以关键字 <code>import</code> 开始，一般语法如下：</p>
<pre><code class="language-wa">import 导入模块路径
</code></pre>
<p>比如下面的例子：</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

import &quot;errors&quot;

func main {
    err := errors.New(&quot;!!!&quot;)
    println(&quot;err:&quot;, err.Error())
}

func getAnswer =&gt; i32 {
    return 42
}
</code></pre>
<p>程序开始处的 <code>import &quot;errors&quot;</code> 声明导入了凹的内置 <code>errors</code> 模块，后续的函数中即可使用该模块的公开对象——如例子中的 <code>errors.New</code> 函数；<code>.</code> 在这里被称为<strong>选择操作符</strong>，它的含义是从左侧的对象（模块）中选择名称与右侧相同的那个对象来使用，该操作符除了用于选择模块公开的函数、全局变量等对象，还用于选择结构体的成员（详见第6章）。</p>
<p>导入声明应位于源文件内的所有非导入声明之前（既位于头部，紧随文件头注释之后）。若导入多个模块，可以使用括号成组导入，形如：</p>
<pre><code class="language-wa">import (
    &quot;errors&quot;
    &quot;strconv&quot;
)
</code></pre>
<p>该声明与下述声明是等价的：</p>
<pre><code class="language-wa">import &quot;errors&quot;
import &quot;strconv&quot;
</code></pre>
<p>在导入模块时，可以给模块起别名，一般语法如下：</p>
<pre><code class="language-wa">import 导入模块路径 =&gt; 模块别名
</code></pre>
<p>这种用法可以解决同时导入两个路径不同，但名字相同的模块时名字冲突的问题，例如：</p>
<pre><code class="language-wa">import (
    &quot;errors&quot;
    &quot;mypackage/errors&quot; =&gt; myerrors
)

func main {
    err := errors.New(&quot;!!!&quot;)     // 调用内置 errors 模块
    myerr := myerrors.New(&quot;!!!&quot;) // 调用 mypackage/errors 模块
}
</code></pre>
<blockquote>
<p>与其他声明不同，<strong>导入声明的作用范围是当前源文件</strong>，如果一个模块内的两个源文件使用了同一个第三方模块，那么两个文件内都需要其导入声明。</p>
</blockquote>
<p>在凹语言中，每个源文件导入的其他模块都<strong>必须被使用</strong>，也就是说，如果导入了一个模块，但并未使用其任何对象，将被视为语法错误。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3-基础数据类型"><a class="header" href="#3-基础数据类型">3. 基础数据类型</a></h1>
<p>从底层而言，所有的数据都是由比特组成。对应的凹语言基础数据类型有整型数、浮点数、字符串等。本章介绍基本数据类型以及局部变量的使用。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="31-局部变量声明"><a class="header" href="#31-局部变量声明">3.1. 局部变量声明</a></h2>
<p>第2章介绍了全局变量和常量声明，同样常用的还有局部变量（函数内部定义的变量）声明，它的一般语法为：</p>
<pre><code class="language-wa">局部变量名: 数据类型 = 初始值
</code></pre>
<p>与全部变量和常量不同的是：局部变量的声明不以关键字开始；在声明局部变量时，如果省略 <code>= 初始值</code> 部分，则该变量将以0值初始化，如：</p>
<pre><code class="language-wa">    aI32: i32 = 42
    aString: string = &quot;你好&quot;
    aF32: f32  // 0.0
</code></pre>
<p>另一种常用的声明局部变量的语法使用快捷定义符 <code>:=</code> ，语法如下：</p>
<pre><code class="language-wa">局部变量名 := 表达式
</code></pre>
<p>使用这种写法时变量的类型将与快捷定义符右侧表达式的类型保持一致，且表达式的值将被赋为该局部变量的初始值，如：</p>
<pre><code class="language-wa">    a := 13          // int
    f := 3.14        // f64
    s := genString() // string
...
func genString() =&gt; string { return &quot;Hello&quot; }
</code></pre>
<blockquote>
<p>凹语言是静态类型语言，合法表达式的类型可以在编译时推定，因此变量的类型是确定的。该 <code>:=</code> 语法类似于C++的 <code>auto</code> 类型。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="32-整数"><a class="header" href="#32-整数">3.2. 整数</a></h2>
<p>凹语言目前支持以下几种整数类型：</p>
<ul>
<li><code>u8</code> ：无符号8位整数；</li>
<li><code>u16</code> ：无符号16位整数；</li>
<li><code>i32</code> ：有符号32位整数；</li>
<li><code>u32</code> ：无符号32位整数；</li>
<li><code>i64</code> ：有符号64位整数；</li>
<li><code>u64</code> ：无符号64位整数；</li>
<li><code>int</code> ：不定宽有符号整数；</li>
<li><code>uint</code> ：不定宽无符号整数；</li>
<li><code>bool</code>：布尔型。</li>
</ul>
<p>其中：</p>
<ul>
<li><code>int</code> 和 <code>uint</code> 为不定宽整数，它们的宽度是由目标平台决定的。之所以有不定宽整数类型，是因为目标平台的寻址范围可能不同，内建函数 <code>len</code> 等涉及存储范围的操作，需要统一的数据类型以保持代码在不同的目标平台上能正常编译，并充分利用平台寻址范围；</li>
<li><code>bool</code> 型实际内存布局为 <code>u8</code>，合法取值的字面值为 <code>true</code>、<code>false</code>，对应内存数值为 1 和 0。</li>
</ul>
<blockquote>
<p>当前凹语言的主要目标平台为 <strong>wasm32</strong>，在该平台下，不定宽整数的位宽为32位，既4字节。</p>
</blockquote>
<p>除布尔型外的整数支持以下单目运算：</p>
<ul>
<li><code>^</code> ：按位取反</li>
<li><code>-</code> ：取算术负值（既用0减去操作数）</li>
</ul>
<p>例如：</p>
<pre><code class="language-wa">    i: u8 = 9
    println(^i) // 246
    println(-i) // 247

    j: i32 = 9
    println(^i) // -10
    println(-i) // -9
</code></pre>
<p>除布尔型外的整数支持以下双目算术运算：</p>
<ul>
<li><code>+</code>：求和，两个操作数类型必须一致，返回值类型与操作数一致；</li>
<li><code>-</code>：求差，两个操作数类型必须一致，返回值类型与操作数一致；</li>
<li><code>*</code>：求积，两个操作数类型必须一致，返回值类型与操作数一致；</li>
<li><code>/</code>：求商，两个操作数类型必须一致，返回值类型与操作数一致；</li>
<li><code>%</code>：求余，两个操作数类型必须一致，返回值类型与操作数一致。</li>
</ul>
<p>例如：</p>
<pre><code class="language-wa">    i, j: u8 = 9, 250
    println(i + j) // 3
    println(i - j) // 15
    println(i * j) // 202
    println(j / i) // 27
    println(j % i) // 7
</code></pre>
<p>除布尔型的整数支持以下双目位运算：</p>
<ul>
<li><code>&amp;</code>：按位取与，两个操作数类型必须一致，返回值类型与操作数一致；</li>
<li><code>|</code>：按位取或，两个操作数类型必须一致，返回值类型与操作数一致；</li>
<li><code>^</code>：按位取异或，两个操作数类型必须一致，返回值类型与操作数一致；</li>
<li><code>&amp;^</code>：按位清空，两个操作数类型必须一致，返回值类型与操作数一致。对 <code>z = x ^&amp; y</code>，设 <code>xn</code>、<code>yn</code>、<code>zn</code> 分别为 <code>x</code>、<code>y</code>、<code>z</code> 的第n位，则当 <code>yn</code> 为1时 <code>zn</code> 为0，否则 <code>zn</code> 等于 <code>xn</code>。该运算等价于 <code>z = x &amp; (^y)</code>；</li>
<li><code>&lt;&lt;</code>：左移，对 <code>z = x &lt;&lt; y</code>，<code>z</code> 的类型与 <code>x</code> 一致，<code>y</code> 必须为大于0的整数，移位时低位补0；</li>
<li><code>&gt;&gt;</code>：右移，对 <code>z = x &gt;&gt; y</code>，<code>z</code> 的类型与 <code>x</code> 一致，<code>y</code> 必须为大于0的整数，移位时高位补0。</li>
</ul>
<p>例如：</p>
<pre><code class="language-wa">    i, j: u16 = 343, 47831
    println(i &amp; j)  // 87
    println(i | j)  // 48087
    println(i ^ j)  // 48000
    println(i &amp;^ j) // 256
    println(i &lt;&lt; 5) // 10976
    println(j &gt;&gt; 5) // 1494
</code></pre>
<p>加、减、乘、左移等运算的结果可能超过操作数的表达范围，此时将截取低位部分作为结果。</p>
<p>除布尔型的整数支持以下比较运算（双目）：</p>
<ul>
<li><code>==</code>：相等。操作数类型必须一致，返回值为 <code>bool</code> 型，符合判断条件返回 <code>true</code>，否则返回 <code>false</code>，下同；</li>
<li><code>!=</code>：不等；</li>
<li><code>&gt;</code>：大于；</li>
<li><code>&gt;=</code>：大等于；</li>
<li><code>&lt;</code>：小于；</li>
<li><code>&lt;=</code>：小等于。</li>
</ul>
<blockquote>
<p>如果参与比较的两个操作数中有一个为常数，则常数应位于比较运算符的右侧。</p>
</blockquote>
<p>布尔型支持以下单目运算：</p>
<ul>
<li><code>!</code>：取反，操作数为 <code>false</code> 返回 <code>true</code>，否则返回 <code>false</code>。</li>
</ul>
<p>实际上除了通过2.4节介绍的常量声明的具名常量外，代码中出现的很多字面值，也是常量，比如：</p>
<pre><code class="language-wa">    i := 13
</code></pre>
<p>代码中的 <code>13</code> 就是一个无类型的整数常量。使用无类型整数常量进行变量快捷声明时，变量的类型为不定宽有符号整数（既 <code>int</code>），上述代码等价于：</p>
<pre><code class="language-wa">    i: int
    i = 13
</code></pre>
<p>将整数常量赋值给整数变量时，会在编译时执行类型和范围检查，自动匹配至变量类型——向无符号整数赋予负数常量、或常量值超过被赋值变量宽度等行为将被判定为非法。</p>
<p>整数拥有所有的二元运算符，二元运算符的优先级按以下顺序递减（同一行内的优先级相同，从左至右执行）：</p>
<pre><code>*      /      %      &lt;&lt;       &gt;&gt;     &amp;       &amp;^
+      -      |      ^
==     !=     &lt;      &lt;=       &gt;      &gt;=
&amp;&amp;
||
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="33-浮点数"><a class="header" href="#33-浮点数">3.3. 浮点数</a></h2>
<p>凹语言目前支持以下两种浮点数（均为IEEE 754标准）：</p>
<ul>
<li><code>f32</code> ：32位浮点数；</li>
<li><code>f64</code> ：64位浮点数.</li>
</ul>
<p>浮点数支持以下单目运算符</p>
<ul>
<li><code>-</code> ：取算术负值（既用0减去操作数）</li>
</ul>
<p>例如：</p>
<pre><code class="language-wa">    i: f32 = 1.25
    println(-i) //-1.25
</code></pre>
<p>浮点数支持以下双目算术运算：</p>
<ul>
<li><code>+</code>：求和，两个操作数类型必须一致，返回值类型与操作数一致；</li>
<li><code>-</code>：求差，两个操作数类型必须一致，返回值类型与操作数一致；</li>
<li><code>*</code>：求积，两个操作数类型必须一致，返回值类型与操作数一致；</li>
<li><code>/</code>：求商，两个操作数类型必须一致，返回值类型与操作数一致；</li>
</ul>
<p>例如：</p>
<pre><code class="language-wa">    i, j: f64 = 1, 0.5
    println(i + j) // 1.5
    println(i - j) // 0.5
    println(i * j) // 0.5
    println(j / i) // 2
</code></pre>
<p>浮点数支持以下比较运算（双目）：</p>
<ul>
<li><code>==</code>：相等。操作数类型必须一致，返回值为 <code>bool</code> 型，符合判断条件返回 <code>true</code>，否则返回 <code>false</code>，下同；</li>
<li><code>!=</code>：不等；</li>
<li><code>&gt;</code>：大于；</li>
<li><code>&gt;=</code>：大等于；</li>
<li><code>&lt;</code>：小于；</li>
<li><code>&lt;=</code>：小等于。</li>
</ul>
<p>使用无类型浮点常量进行变量快捷声明时，变量的类型为 <code>f64</code>，如下面两种写法是等价的：</p>
<pre><code class="language-wa">    f := 1.5
</code></pre>
<pre><code class="language-wa">    f: f64 = 1.5
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="34-字符串"><a class="header" href="#34-字符串">3.4. 字符串</a></h2>
<p>字符串在凹语言中被视为基础数据类型，类型名称为：<code>string</code>，字符串字面常量通过双引号 <code>&quot;&quot;</code> 括起定义，采用 UTF-8 编码，例如：</p>
<pre><code class="language-wa">    s: string = &quot;你好，凹语言&quot;
    println(s)     // 你好，凹语言
    println(&quot;+42&quot;) // +42
</code></pre>
<p>与整数、浮点数类似，字符串变量也可以使用 <code>:=</code> 快捷定义，例如：</p>
<pre><code class="language-wa">    s := &quot;编号9527&quot;
</code></pre>
<p>字符串支持加法（<code>+</code>）双目操作，返回值为两个字符串的连接，例如：</p>
<pre><code class="language-wa">    s1 := &quot;abc&quot;
    s2 := &quot;123&quot;
    println(s1 + s2) // abc123
</code></pre>
<p>容纳字符串的底层结构是一个字节（既<code>u8</code>）数组，可以使用 <code>[]</code> 获取其中某个字节的数值，或一个子串，例如：</p>
<pre><code class="language-wa">    s := &quot;abcdefg&quot;
    println(s[2])   // 99，既 'c' 的ASCII值
    println(s[1:3]) // bc
</code></pre>
<p>在这种用法中，<code>[]</code> 内的下标单位是<strong>字节</strong>，而不是<strong>字符</strong>。如果源字符串包含非 ASCII 码字符（如中文字符），而下标未处于整字符边界处，则返回的子字串可能非法，例如：</p>
<pre><code class="language-wa">    s := &quot;你好&quot;
    println(s[1:3]) // ��
</code></pre>
<p><code>s[m:n]</code> 用法从第<code>n</code>个字节处开始截取，返回的字串长度为 <code>n-m</code> 字节。若省略 <code>m</code> 则表示从字符串开始截取，若省略 <code>n</code> 则表示截取至字符串末尾，例如：</p>
<pre><code class="language-wa">    s := &quot;abcdefg&quot;
    println(s[:3]) // abc
    println(s[3:]) // defg
</code></pre>
<p>从底层数据的角度看，截取子字符串时没有重新申请字节数组拷贝，而是直接引用原始字符串的地址。为避免多个引用同一片内存的字符串相互修改的影响，字符串被设定为不能局部修改——既不能向 <code>s[n]</code> 赋值。下述写法是非法的：</p>
<pre><code class="language-wa">    s := &quot;abcdefg&quot;
    s[0] = 99 // 非法操作
</code></pre>
<p>两个字符串间可使用 <code>==</code>、<code>!=</code> 运算符进行相等、不等判断，例如：</p>
<pre><code class="language-wa">    s := &quot;abc&quot;
    println(s == &quot;123&quot;) // false
    println(s != &quot;123&quot;) // true
</code></pre>
<p>内建函数 <code>len</code> 可用于获取字符串长度（以字节为单位），如：</p>
<pre><code class="language-wa">    s := &quot;abcdefg&quot;
    println(len(s)) // 7
</code></pre>
<hr />
<p>已知问题列表：</p>
<ul>
<li>使用 <code>[]</code> 获取字符串变量的指定字节或子串时，未执行边界检查。该问题不影响语法兼容性，后续对本问题的修正不影响已有源代码，凹程序开发者无须对此进行特别处理。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="4-函数"><a class="header" href="#4-函数">4. 函数</a></h1>
<p>函数是语句序列的打包，以便于被多次重复使用。本章介绍凹语言函数基本用法，以及函数值、匿名函数和闭包等特性。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="41-函数调用"><a class="header" href="#41-函数调用">4.1. 函数调用</a></h2>
<p>我们在之前的章节中已接触过很多函数，比如常用的内置打印函数 <code>println</code>。函数调用的一般语法为：</p>
<p><code>函数名(实参列表)</code></p>
<p><code>实参</code>指函数调用时实际传入的参数，与之对应的是函数声明时定义的<code>形参</code>，形参只在函数体内有效。凹语言在调用函数时，参数使用<strong>值传递</strong>，在函数体内对形参值的变更不会影响实参的值，例如：</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

func Double(i: i32) =&gt; i32 {
    i = i * 2
    return i
}

func main {
    j: i32 = 42
    println(Double(j)) // 84
    println(j)         // 42
}
</code></pre>
<p>关键字 <code>return</code> 用于退出函数并返回值，一般语法为：</p>
<pre><code class="language-wa">return 返回值列表
</code></pre>
<p>如果函数有多个返回值，应使用 <code>,</code> 分隔，例如：</p>
<pre><code class="language-wa">func MulRet() =&gt; (i32, i32) {
    return 42, 13
}
</code></pre>
<p>类似于形参，函数声明时可定义具名返回值，例如：</p>
<pre><code class="language-wa">func showAnswer() =&gt; (answer: i32) {
    answer = 42
    return
}
</code></pre>
<p>这种写法等价于：</p>
<pre><code class="language-wa">func showAnswer() =&gt; i32 {
    answer: i32
    answer = 42
    return answer
}
</code></pre>
<p>与其他变量类似，具名返回值以 0 值初始化。假如某个函数需要返回错误码、分支很多并且大多数分支错误码为 0 值，则使用具名返回值写法可以简化代码。</p>
<p>即使声明了具名返回值，<code>return</code> 时仍然可以指定别的值，比如：</p>
<pre><code class="language-wa">// 版权 @2019 凹语言 作者。保留所有权利。

func showAnswer() =&gt; (answer: i32) {
    answer = 13
    return 42
}

func main {
    println(showAnswer()) // 42
}
</code></pre>
<p>因此我们可以这样来理解：具名返回值实际上是在函数体内定义了一组局部变量，当该函数内的<code>return</code> 语句未指明返回值时，自动将这一组局部变量作为返回值填入。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="42-函数值"><a class="header" href="#42-函数值">4.2. 函数值</a></h2>
<p>在凹语言中，函数可以被当作一种特殊的值，例如：</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

func Inc(i: i32) =&gt; i32 { return i + 1 }
func Dec(i: i32) =&gt; i32 { return i - 1 }

func main {
    f := Inc
    println(f(42)) // 43

    f = Dec
    println(f(42)) // 41
}
</code></pre>
<p>上例中，<code>f</code> 即为<strong>函数值</strong>，函数值可以被调用，调用方法与函数调用无异。</p>
<p>函数的类型由其参数以及返回值类型决定，通常这些信息被称为<strong>函数签名</strong>（Signature），如果两个函数 A 和 B 拥有相同签名，意味着它们：</p>
<ul>
<li>参数个数相同；</li>
<li>返回值个数相同；</li>
<li>对于任意 n，函数 A 的第 n 个参数的类型与 B 的第 n 个参数类型相同；</li>
<li>对于任意 m，函数 A 的第 m 个返回值的类型与 B 的第 m 个返回值类型相同。</li>
</ul>
<p>函数值的类型也是通过函数签名定义的，比如上例中函数值 <code>f</code> 的类型为 <code>func(i32) =&gt; i32</code>，因此上例中 <code>f</code> 的快捷声明 <code>f := Inc</code> 等价于：</p>
<pre><code class="language-wa">    f: func(i32) =&gt; i32 // f == nil
    f = Inc
</code></pre>
<blockquote>
<p>与其他类型的值一样，函数值也为0值初始化，对应值为 <code>nil</code></p>
</blockquote>
<p>在凹语言中，类型不同的值不能相互赋值，这一点对函数值同样有效，由于函数类型由签名确定，因此将一个函数赋值给签名不同的函数值被视为非法，例如：</p>
<pre><code class="language-wa">func Inc(i: i32) =&gt; i32 { return i + 1 }

func main {
    f: func(i32)
    f = Inc // 编译错误
}
</code></pre>
<p>既然被称为“值”，意味着函数值可以作为参数、和返回值在不同函数间传递，例如：</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

func inc(i: i32) =&gt; i32 { return i + 1 }
func dec(i: i32) =&gt; i32 { return i - 1 }
func getFunc(opCode: i32) =&gt; func(i32) =&gt; i32 {
    if opCode == 0 {
        return inc
    } else if opCode == 1 {
        return dec
    } else {
        return nil
    }
}

func useFunc(i: i32, f: func(i32) =&gt; i32) {
    if f == nil {
        println(&quot;f == nil&quot;)
        return
    }
    println(f(i))
}

func main {
    useFunc(42, getFunc(0)) // 43
    useFunc(42, getFunc(1)) // 41
    useFunc(42, getFunc(2)) // f == nil
    getFunc(2)(42)          // 运行时异常
}
</code></pre>
<p>与其他基本类型不同，函数值只能与 <code>nil</code> 比较，既：函数值位于操作符 <code>==</code>、<code>!=</code> 左侧时，右侧只能为 <code>nil</code>，对两个非常量函数值执行比较操作被视为非法。</p>
<p>如果被调用的函数值为 <code>nil</code>，将触发不可恢复的运行时异常。</p>
<p>函数值与 C 系语言中的函数指针作用类似，可以更灵活的动态调整执行分支。但需要指出的时，相比于直接调用函数，调用函数值有一些额外消耗，性能敏感的场合需要格外注意。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="43-匿名函数及闭包"><a class="header" href="#43-匿名函数及闭包">4.3. 匿名函数及闭包</a></h2>
<p>上一节介绍了函数值的基本用法，既然函数可被视为值，那么，在凹语言函数内部，是否可以像声明基本类型字面量那样，声明函数字面量？答案是肯定的，例如：</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

func useFunc(i: i32, f: func(i32) =&gt; i32) {
    if f == nil {
        println(&quot;f == nil&quot;)
        return
    }
    println(f(i))
}

func main {
    f := func(i: i32) =&gt; i32 { return i * i } // 声明匿名函数并赋值给 f
    useFunc(3, f) // 9
}
</code></pre>
<p>其中快捷声明的函数值 <code>f</code>，它的初始值是字面量 <code>func(i: i32) =&gt; i32 { return i * i }</code>，既一个没有名字的函数。在凹语言中，这种没有名字的函数字面量被称为<strong>匿名函数</strong>。在访问者模式、自定义快速排序等应用场景中，经常需要传入一些函数值参数，而这些函数可能仅在当前上下文环境出现一次，为此额外定义模块级的全局函数有诸多不便，这时即可使用匿名函数。</p>
<p><strong>在函数A内部声明的匿名函数B，可以访问A内部的局部变量</strong>，例如：</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

func useFunc(i: i32, f: func(i32) =&gt; i32) {
    if f == nil {
        println(&quot;f == nil&quot;)
        return
    }
    println(f(i))
}

func main {
    n: i32 = 0
    f := func(i: i32) =&gt; i32 {
        n = i * i
        return n
    }
    useFunc(3, f)
    println(n) // 9
}
</code></pre>
<p>可见函数值 <code>f</code> 可以读写外层的局部变量 <code>n</code>。再来看一个更加复杂的例子：</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。
func genClosure(i: i32) =&gt; func() =&gt; i32 {
    n := i
    return func() =&gt; i32 {
        n = n + 1
        return n
    }
}

func main {
    c := genClosure(0)
    d := genClosure(99)

    println(c()) // 1
    println(d()) // 100
    println(c()) // 2
    println(d()) // 101
}
</code></pre>
<p>每次调用 <code>genFunc</code> 都将生成一个函数值，这个函数值捕获了局部变量 <code>n</code>，函数值每次执行会对捕获的 <code>n</code> 执行加1，多次执行 <code>genFunc</code> 所获得的函数值，它们捕获的 <code>n</code> 是不同的，每执行一次，捕获一个新的实例。</p>
<p>在函数内声明的匿名函数值，携带了本次运行时捕获的局部变量的状态。显然，这种函数值实质上就是闭包。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="44-条件语句"><a class="header" href="#44-条件语句">4.4. 条件语句</a></h2>
<p>条件语句的一般形式为：</p>
<pre><code class="language-wa">    if 初始语句, 条件表达式 {
        代码块1
    } else {
        代码块2
    }
</code></pre>
<p>其中，<code>条件表达式</code> 必须为布尔型，条件语句先执行可选的<code>初始语句</code>（<code>初始语句,</code> 可省略，此时表示没有初始动作），然后判断 <code>条件表达式</code> 是否为 <code>true</code>，是则执行 <code>代码块1</code>，否则执行 <code>代码块2</code>。如果<code>条件表达式</code> 为 <code>false</code> 时无需执行任何操作，那么 <code>else {...}</code> 可省略。</p>
<p>需要注意的是，凹语言默认换行为语句结束，因此 <code>else</code> 语句需要跟 <code>if</code> 代码块的 <code>}</code> 位于同行，若 <code>else</code> 新起一行，将产生编译错误。</p>
<p>下面是一个多重条件判断的例子：</p>
<pre><code class="language-wa">func Compare(x, y: int) =&gt; int {
    if x &lt; y {
        return 1
    } else if x &gt; y {
        return -1
    } else {
        return 0
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="45-循环语句"><a class="header" href="#45-循环语句">4.5. 循环语句</a></h2>
<p>循环语句有三种基本形式：</p>
<pre><code class="language-wa">    for { 代码块 }
    for 条件表达式 { 代码块 }
    for 初始语句; 条件表达式; 循环操作语句 { 代码块 }
</code></pre>
<p>其中 <code>for { 代码块 }</code> 将一直循环，直到代码块内的语句使用 <code>break</code> 关键字退出循环，使用 <code>continue</code> 关键字将略过后续语句，执行下一次循环，例如：</p>
<pre><code class="language-wa">    i: int
    for {
        i++
        if i == 2 {
            continue
        }
        println(i)
        if i == 3 {
            break
        }
    }
</code></pre>
<p>上述代码将输出：</p>
<pre><code>1
3
</code></pre>
<p><code>for 条件表达式 { 代码块 }</code> 循环每次执行 <code>代码块</code> 前会判断 <code>条件表达式</code> 是否为 <code>true</code>，是则执行代码块，否则退出循环。在代码块内的语句也可以使用 <code>break</code>、<code>continue</code> 退出循环或跳过后续语句执行下一次循环：</p>
<pre><code class="language-wa">    i: int
    for i &lt; 3 {
        println(i)
        i++
    }
</code></pre>
<p><code>for 初始语句; 条件表达式; 循环操作语句 { 代码块 }</code> 循环先执行一次 <code>初始语句</code>，然后每次执行 <code>代码块</code> 前判断 <code>条件表达式</code> 是否为 <code>true</code>，是则执行代码块，否则退出循环；每次代码块执行后，会执行一次 <code>循环操作语句</code>。在代码块中使用 <code>break</code> 关键字将直接退出循环，使用 <code>continue</code> 关键字将跳过后续语句执行下一次循环（此时 <code>循环操作语句</code> 仍然会被执行），例如：</p>
<pre><code class="language-wa">    for i := 0; i &lt; 100; i++ {
        if i == 1 {
            continue
        }
        println(i)
        if i == 2 {
            break
        }
    }
</code></pre>
<p>上述代码将输出：</p>
<pre><code>0
2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="46-分支语句"><a class="header" href="#46-分支语句">4.6. 分支语句</a></h2>
<p>分支语句常用于替代多重条件语句，一般形式为：</p>
<pre><code class="language-wa">    switch 初始语句, 条件表达式 {
    case 分支表达式1:
        代码块1

    case 分支表达式2:
        代码块2

    default:
        默认代码块
    }
</code></pre>
<p>分支语句首先会执行可选的 <code>初始语句</code>（<code>初始语句,</code> 可省略，此时表示没有初始动作），然后从上至下判断 <code>条件表达式</code> 的值是否与某条 <code>分支表达式</code> 相等，若相等，则执行对应分支的 <code>代码块</code>；若所有分支条件均不满足，则执行可选的 <code>默认代码块</code>（省略 <code>default</code> 分支表示没有默认代码块）。例如：</p>
<pre><code class="language-wa">func f(x: int) {
    switch x {
    case 0:
        println(&quot;x 为 0&quot;)

    case 1:
        println(&quot;x 为 1&quot;)

    default:
        println(&quot;x ==&quot;, x)
    }
}
</code></pre>
<p>注意凹语言中分支语句默认跳出：进入某个分支，执行完对应代码块后，将直接跳出分支语句（既隐式<code>break</code>），这与 C系语言的默认行为相反。</p>
<p>分支语句另一个特殊的用于类型断言的用法见 7.1节。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="5-复合数据类型"><a class="header" href="#5-复合数据类型">5. 复合数据类型</a></h1>
<p>复合数据类型是内置的复杂类型的基础。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="51-引用"><a class="header" href="#51-引用">5.1. 引用</a></h2>
<p>在凹语言中，在一个变量前添加 <code>&amp;</code> 符号被称为 <strong>取引用</strong> 操作，假设该变量的类型为 <code>T</code>，取引用操作返回值的类型为 <code>*T</code>，被称为 <strong>T型引用</strong>，例如：</p>
<pre><code class="language-wa">    i: i32 = 42
    j := &amp;i // j的类型为 *i32 ，既：i32型引用
</code></pre>
<p>在引用型变量前添加 <code>*</code> 符号被称为 <strong>解引用</strong> 操作，解引用表达式的值为它所引用的原始变量的值，例如：</p>
<pre><code class="language-wa">    i: i32 = 42
    j := &amp;i
    println(*j) // 42
</code></pre>
<p>在这里 <code>*j</code> 返回了 <code>i</code> 的值，类型与 <code>i</code> 一样为 <code>i32</code>。解引用可以被赋值，其作用为向被引用的原始变量赋值，例如：</p>
<pre><code class="language-wa">    i: i32 = 13
    j := &amp;i
    *j = 42
    println(i) // 42
</code></pre>
<p>由此可见，凹语言中的<strong>引用</strong>与C系语言中的<strong>指针</strong>作用类似，但由于凹语言使用自动内存管理，这种相似性仅存在于表面，因此我们使用<strong>引用</strong>这一术语以示区别。二者最显著的不同，可通过下面这个例子窥见一斑：</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

func genI32Ref() =&gt; *i32 {
    i: i32 = 9527
    return &amp;i
}

func main {
    p := genI32Ref()
    *p = 13
    q := genI32Ref()
    println(*p) // 13
    println(*q) // 9527
}
</code></pre>
<p>在凹语言中，<strong>跨函数传递引用是合法操作</strong>。返回局部变量的引用安全无害，编译器和运行时会跟踪变量使用的内存，自动执行清理回收。当然这导致了引用与指针的另一个直观的不同，既：引用不能执行算术运算。</p>
<p>对于引用类型 <code>*T</code>，<code>T</code> 可以是基础类型，也可以是任何复合类型或自定义类型，<code>**T</code> 这样的多级引用（类似于C语言多级指针）也是合法的。</p>
<hr />
<p>已知问题列表：</p>
<ul>
<li>目前使用的RC模式无法自动回收孤环，进而导致内存泄漏。该问题不影响语法兼容性，后续对本问题的修正不影响已有源代码，凹程序开发者无须对此进行特别处理。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="52-数组"><a class="header" href="#52-数组">5.2. 数组</a></h2>
<p>数组类型的基本声明如下：</p>
<pre><code class="language-wa">[N]T
</code></pre>
<p>其中，<code>N</code> 为数组长度（大等于0常整数），<code>T</code> 为数组元素类型；例如：</p>
<pre><code class="language-wa">    a: [3]i32
    a[0] = 42
    println(a[0]) // 42
</code></pre>
<p>与很多语言类似，凹语言使用 <code>x[M]</code> 语法访问数组内的指定元素。数组变量声明时，可使用以下方式设定数组元素初始值：</p>
<pre><code class="language-wa">    a: [3]i32 = 
    println(a[0], a[1], a[2]) // 13 42 9527
</code></pre>
<p><code>[3]i32{13, 42, 9527}</code> 声明了一个数组字面值，因此上例中数组变量 <code>a</code> 的声明可以使用快捷声明简化为：</p>
<pre><code class="language-wa">    a := [3]i32{13, 42, 9527}
</code></pre>
<p>声明数组字面值时，其后 <code>{}</code> 内所含元素的个数可以小于数组长度（但不可大于），不足的部分为 0 值，例如：</p>
<pre><code class="language-wa">    a := [3]i32{13, 42}
    println(a[2]) // 0
</code></pre>
<p>内置函数 <code>len</code> 可用于获取数组长度既数组中所含元素的个数，例如：</p>
<pre><code class="language-wa">    a := [3]i32
    println(len(a)) // 3
</code></pre>
<p>声明数组字面值时，若数组长度部分写为 <code>...</code>，则表明数组长度由其后 <code>{}</code> 内的元素个数决定，例如：</p>
<pre><code class="language-wa">    a := [...]i32{13, 42}
    println(len(a)) // 2
</code></pre>
<p><strong>在凹语言中数组是值类型</strong>，例如：</p>
<pre><code class="language-wa">    a := [...]i32{13, 42}
    b: [2]i32
    b = a
    println(b[0], b[1]) // 13 42
    b[0] = 9527
    println(a[0]) // 13
</code></pre>
<p>由此可见，将一个数组赋值给另一个数组时，会将其中的每个对应元素都进行赋值，既执行深拷贝操作。由于数组是值，赋值后的数组间不存在相互关联。</p>
<p>元素类型相同，但长度不同的数组，被认为是不同的类型，因此下列程序非法：</p>
<pre><code class="language-wa">    a: [2]i32
    b: [3]i32
    b = a // 非法，类型不同不可赋值
</code></pre>
<hr />
<p>已知问题：</p>
<ul>
<li>通过变量下标访问数组元素时，未执行边界检查。该问题不影响语法兼容性，后续对本问题的修正不影响已有源代码，凹程序开发者无须对此进行特别处理。</li>
<li>在目前版本的实现中，数组被展开为一组线性值，因此数组赋值时，虚拟寄存器和指令数与数组长度成整倍数关系，若长度过大，目标代码的体积会急剧膨胀。该问题不影响语法兼容性，后续对本问题的修正不影响已有源代码，在现阶段，程序开发者应关注：除全局变量外，尽可能不要使用长度大于8的数组。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="53-切片"><a class="header" href="#53-切片">5.3. 切片</a></h2>
<p>切片类型的基本声明如下，<code>T</code> 为元素类型：</p>
<pre><code class="language-wa">[]T
</code></pre>
<p>切片的第一印象与数组很相似：它们都是特定类型对象的序列，但它们的实际行为存在巨大区别，<strong>切片是数组的部分引用</strong>，它时常取自于数组，例如：</p>
<pre><code class="language-wa">    arr := [...]i32{1, 2, 3, 4}
    sl: []i32 = arr[0:2]
    println(len(sl))      // 2
    println(sl[0], sl[1]) // 1 2
</code></pre>
<p>表达式 <code>arr[m:n]</code> 返回一个切片，切片始于数组 <code>arr</code> 的第 <code>m</code> 个元素，切片长度为 <code>n-m</code>，与字符串的类似语法相似，若省略 <code>m</code>，则表示始于数组首个元素；若省略 <code>n</code>，则终于数组最后一个元素。<code>m</code> 和 <code>n</code> 不可超过数组实际范围，否则会触发异常。</p>
<p>切片中并不保存实际数据，通过 <code>[]</code> 访问到的对象位于它所引用的数组中，这意味着更改数组中的对象可能影响到切片，反之亦然，例如：</p>
<pre><code class="language-wa">    arr := [...]i32{1, 2, 3, 4}
    sl := arr[0:2]
    println(sl[0]) // 1
    arr[0] = 13
    println(sl[0]) // 13
    sl[1] = 42
    println(arr[1]) // 42
</code></pre>
<p>内置函数 <code>cap</code> 可用于获取切片的可用容量——既切片所引用的数组的长度减去切片开始位置，例如：</p>
<pre><code class="language-wa">    arr := [...]i32{11, 12, 13, 14}
    sl1 := arr[1:2]
    println(len(sl1), cap(sl1)) // 2 3
</code></pre>
<p>由定义可知，切片的容量恒大等于其长度。</p>
<p>一个数组可以被多个切片引用，如果引用的部分之间存在重叠，那么重叠部分的更改也会互相影响，例如：</p>
<pre><code class="language-wa">    arr := [...]i32{1, 2, 3, 4}
    sl1 := arr[0:2]
    sl2 := arr[1:3]
    println(sl2[0]) // 2
    sl1[1] = 42
    println(sl2[0]) // 42
</code></pre>
<p>实际上，对切片使用<code>[m:n]</code>操作符也可以获得一个新的切片，新切片始于源切片的第 <code>m</code> 个元素，其余规则与从数组中获取一个切片类似。</p>
<p>获取切片的方法除了引用数组或已有切片外，还可以通过内置函数 <code>make</code> 直接创建，形式签名为：</p>
<pre><code class="language-wa">make([]T, Len: int, Cap: int) =&gt; []T
make([]T, Len: int) =&gt; []T // 等价于 make([]T, Len, Len)
</code></pre>
<p>返回值是一个类型为 <code>[]T</code>、长度为 <code>Len</code>、容量为 <code>Cap</code> 的切片，其中 <code>Cap</code> 可以省略，此时切片的容量为 <code>Len</code>，例如：</p>
<pre><code class="language-wa">    sl1 := make([]i32, 3, 5)
    println(sl1[0], len(sl1), cap(sl1)) // 0 3 5
</code></pre>
<p>使用 <code>make</code> 函数创建切片时，隐式的创建了一个长度为 <code>Cap</code> 的数组，并将其引用为切片。</p>
<p>另一个与切片密切相关的内建函数是 <code>append</code>，它用于向切片中追加元素，形式签名为：</p>
<pre><code class="language-wa">append(sl []T, e T) =&gt; []T
</code></pre>
<p>该函数将元素 <code>e</code> 追加至切片 <code>s</code> 的尾部，并返回一个新的切片。由于凹语言的函数调用使用值传递，追加行为不会影响源切片 <code>s</code> 上，因此实际常用的写法如下例：</p>
<pre><code class="language-wa">    sl: []i32
    //...
    sl = append(sl, 42)
</code></pre>
<p>既将 <code>append</code> 返回的新切片赋值给源切片。<code>append</code> 不仅向切片中追加元素，还可以追加另一个切片，例如：</p>
<pre><code class="language-wa">    sl1 := []i32{13, 42}
    sl2 := []i32{9527, 1024}
    sl1 = append(sl1, sl2...)
    println(sl1[0], sl1[1], sl1[2], sl1[3]) // 13 42 9527 1024
</code></pre>
<p>当被追加对象是切片时，应在变量名后添加 <code>...</code>。</p>
<p>由于切片底层引用了一个长度固定的数组，如果使用 <code>append</code> 追加元素后，切片的长度未超过数组可用容量，那么数组对应元素的内容将被替换为追加元素，例如：</p>
<pre><code class="language-wa">    arr := [...]i32{1, 2, 3}
    sl1 := arr[0:3]
    sl1 = append(sl1, 5)
    println(arr[2]) // 5    
</code></pre>
<p>倘若新切片的长度超过原始数组容量，那么 <code>append</code> 函数会自动重新申请一个足够大的数组，将源切片的元素拷贝至新数组（既自动执行了一次深拷贝），然后再执行追加，这种情况我们称为切片扩容，例如：</p>
<pre><code class="language-wa">    arr := [...]i32{1, 2, 3}
    sl1 := arr[:]
    sl2 := append(sl1, 4)
    sl2[0] = 42
    println(sl1[0]) // 1
</code></pre>
<p>显然，如果发生了切片扩容，新切片与源切片的相互引用关系就切断了。</p>
<p>与前面章节介绍过的数据类型不同，切片类型的变量<strong>不可比较</strong>，因为切片不是纯值类型，而是与底层数组甚至其他切片存在引用关系，这种关联使得切片在运行时无法保证其中的元素值不变。</p>
<p>切片只能与常量 <code>nil</code> 进行比较，用于判断切片是否为 0 值，例如：</p>
<pre><code class="language-wa">    sl: []i32
    println(sl == nil, sl != nil) // true false
</code></pre>
<p>实际上，如果需要判断某个切片是否为空，不应将其与 <code>nil</code> 比较，而应判断其长度是否为 0，因为存在长度为 0，但不为 <code>nil</code> 的切片，例如：</p>
<pre><code class="language-wa">    arr := [...]i32{1, 2, 3}
    sl1 := arr[0:0]
    println(sl1 == nil, len(sl1), cap(sl1)) // false 0 3
</code></pre>
<p>除特别说明外，凹语言程序应以相同的方式处理长度为 0 的切片，与 <code>nil</code> 值的切片。内置函数 <code>append</code> 既符合该要求，例如下列程序是合法的：</p>
<pre><code class="language-wa">    sl: []i32 // sl == nil
    sl := append(sl, 5)
    println(sl[0]) // 5
</code></pre>
<hr />
<p>已知问题：</p>
<ul>
<li>访问切片元素时，未执行边界检查。该问题不影响语法兼容性，后续对本问题的修正不影响已有源代码，凹程序开发者无须对此进行特别处理。</li>
<li>使用 <code>[]</code> 从数组或切片中获取新切片时，未执行边界检查。该问题不影响语法兼容性，后续对本问题的修正不影响已有源代码，凹程序开发者无须对此进行特别处理。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="6-自定义类型"><a class="header" href="#6-自定义类型">6. 自定义类型</a></h1>
<p>自定义类型主要是结构体、以及围绕结构体方法产生的接口抽象。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="61-结构体"><a class="header" href="#61-结构体">6.1. 结构体</a></h2>
<p>凹语言中结构体声明的一般形式为：</p>
<pre><code class="language-wa">type 类型名 struct {
    成员列表
}
</code></pre>
<p>其中<code>成员列表</code>的部分与变量声明格式一致，比如下例：</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

type Info struct {
    name: string
    age:  i32
}

func PrintInfo(i: Info) {
    println(&quot;名字：&quot;, i.name, &quot;，年龄：&quot;, i.age)
}

func main {
    i: Info
    i.name = &quot;张三&quot;
    i.age = 35
    PrintInfo(i) // 名字： 张三 ，年龄： 35
}
</code></pre>
<p>与很多语言类似，凹语言 使用选择操作符 <code>.</code> 访问结构体值的成员。另外需要特别注意的是，选择操作符 <code>.</code> 也可以用于访问结构体引用的成员，例如：</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

type Info struct {
    name: string
    age:  i32
}

func GetInfo() =&gt; *Info {
    i: Info
    i.name = &quot;李四&quot;
    i.age = 42
    return &amp;i
}

func main {
    j := GetInfo() // j 的类型是引用， *Info
    println(j.name, j.age) // 李四 42
}
</code></pre>
<p>由此可见，无论是值还是引用，访问其成员的方式是一致的，这与 C 语言不同（C 语言使用 <code>-&gt;</code> 访问结构体指针的成员）。</p>
<p>结构体的成员类型，不能包含结构体本身，因为这会引起无限嵌套；事实上任何会引起无限嵌套的结构体都是非法的，比如两个结构体互相包含对方。但是结构体中包含本类型的引用是合法的（因为引用的实质是指针），这种用法常用于创建链表结构，比如：</p>
<pre><code class="language-wa">type Node struct {
    data: i32
    next: *Node
}
</code></pre>
<p>结构体字面值的例子如下：</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

type Info struct {
    name: string
    age:  i32
}

func main {
    i := Info{name: &quot;王五&quot;}
    println(j.name, j.age) // 王五 0
}
</code></pre>
<p>在声明结构体字面值时 <code>{}</code> 内为成员字面值列表，未列出的成员为 0 值。</p>
<p>如果结构体内的所有成员变量都可比（既该成员类型的变量间可执行 <code>==</code> 操作），则该结构体的变量间也可比。在目前已介绍的数据类型中，切片是不可比类型，因此直接或间接包含切片的结构体均不可比。与其他类型的声明类似，结构体可在模块内的任意文件中声明，且无需“先声明再使用”。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="62-方法"><a class="header" href="#62-方法">6.2. 方法</a></h2>
<p>自定义类型除了可以通过结构体达到对成员数据的封装外，最大的作用是它们可以拥有<strong>方法</strong>。在凹语言中，<strong>方法</strong>是一类特殊的、依附于特定类型的函数，见下例：</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

type Info struct {
    name: string
    age:  i32
}

// 方法声明：
func Info.Print {
    println(&quot;名字：&quot;, this.name, &quot;，年龄：&quot;, this.age)
}

func main {
    i := Info{name: &quot;张三&quot;, age: 35}
    i.Print() // 名字： 张三 ，年龄： 35
}
</code></pre>
<p>方法声明一般形式如下，：</p>
<pre><code class="language-wa">func 类型名.方法名(参数列表) =&gt; (返回值列表) {方法函数体}
</code></pre>
<p>方法声明与普通全局函数声明的区别是函数名的部分增加了 <code>类型名.</code> 。在方法体内部，<code>this</code> 是方法所属类型的引用，通过 <code>this.</code> 可读写其成员。</p>
<p>如果仅从目前已介绍的语法来看，方法和全局函数可以完成同样的功能，比如上述例子和下面的代码几乎等价：</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

type Info struct {
    name: string
    age:  i32
}

func Print(this: *Info) {
    println(&quot;名字：&quot;, this.name, &quot;，年龄：&quot;, this.age)
}

func main {
    i := Info{name: &quot;张三&quot;, age: 35}
    Print(&amp;i) // 名字： 张三 ，年龄： 35
}
</code></pre>
<p>如上例所示，如果把全局函数的第一个参数设为自定义类型的引用，那么它的作用和方法几乎是一致的——事实上在凹语言中，从运行时层面看，方法就是首参数为自定义类型引用的函数。既然如此，那么为何要特意引入这一概念呢？原因有两个：</p>
<ol>
<li>方法有助于聚合对象的功能；</li>
<li><code>接口</code> 这一概念直接依赖于方法——类型的方法集合决定了它所实现的接口，第7章将对此进行介绍。</li>
</ol>
<blockquote>
<p>需要特别注意的是，按照凹语言语法，使用 <code>func T.xxx()...</code> 声明的方法并不属于类型 <code>T</code>，而是属于类型 <code>*T</code>——既 <code>T</code> 的引用；也就是说具名类型本身不能拥有方法，拥有方法的只能是具名类型的引用。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="63-方法值"><a class="header" href="#63-方法值">6.3. 方法值</a></h2>
<p>由于方法也是函数，因此可以仿照 4.2 节的模式使用它，例如：</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

type Vertex struct{
    x, y: i32
}

func Vertex.Scale(s: i32) {
    this.x *= s
    this.y *= s
}

func Vertex.Sub(s: i32) {
    this.x -= s
    this.y -= s
}

func Vertex.Print {
    println(&quot;x:&quot;, this.x, &quot;y:&quot;, this.y)
}

func FnOp(s: i32) {
    println(&quot;FnOp, s:&quot;, s)
}

func main {
    v := Vertex{x: 100, y:200}
    op : func(s: i32)

    op = FnOp // op此时是函数值FnOp
    op(13) // FnOp, s: 13

    op = v.Scale // op此时是方法值v.Scale
    op(2)
    v.Print() // x: 200 y: 400

    op = v.Sub // op此时是方法值v.Sub
    op(50)
    v.Print() // x: 150 y: 350
}
</code></pre>
<p><code>v.Scale</code>、<code>v.Sub</code> 是结构体变量 <code>v</code> 的方法，当它们被当成值来使用时，被称为<strong>方法值</strong>，比如上例中，它们先后被赋值给了 <code>op</code>。方法值可以像普通函数值那样被调用，并且调用时可以影响方法上关联的引用（就如同直接调用原始方法那样），由此可见方法值捕获了原始对象引用，是<code>带状态</code>的，在这一点上，方法值与闭包存在相似性。</p>
<p>从上例中还可以得知：函数值变量（比如例中的 <code>op</code>），既可以存储函数值，也可以存储方法值，对调用方（caller）来说，二者没有区别。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="64-嵌入结构体"><a class="header" href="#64-嵌入结构体">6.4. 嵌入结构体</a></h2>
<p>在声明结构体类型时，如果某个成员的类型是结构体，但省略该成员的名称，这种用法被称为<strong>嵌入结构体</strong>，例如下面代码中，结构体 <code>Sc</code> 中嵌入了 <code>Sp</code> 成员：</p>
<pre><code class="language-wa">type Sp struct {
    x: i32
}

type Sc struct {
    Sp // 嵌入结构体
    y: i32
}
</code></pre>
<p>嵌入结构体的成员名称就是其类型名称，我们依然可以使用选择符 <code>.</code> 访问它，例如下面的打印代码：</p>
<pre><code class="language-wa">    v: Sc
    println(v.Sp.x)
</code></pre>
<p>在这个例子中，甚至可以省略 <code>.Sp</code> 的部分，比如上面的代码跟下述代码是等价的：</p>
<pre><code class="language-wa">    v: Sc
    println(v.x)
</code></pre>
<p>在这种用法中，结构体 <code>Sp</code> 看起来似乎被嵌到结构体 <code>Sc</code> 中去了，这也是<strong>嵌入结构体</strong>名称的来源。但是如果结构体中包含了和被嵌结构体同样名称的成员，则访问被嵌结构体同名成员时不能进行省略，例如：</p>
<pre><code>// 版权 @2023 凹语言 作者。保留所有权利。

type Sp struct {
    x: i32
}

type Sc2 strct {
    Sp
    x: f32
}

func main(){
    v: Sc2
    println(v.x)    // 打印的是Sc2.x，f32类型
    println(v.Sp.x) // 打印的是Sc2.Sp.x，i32类型
}
</code></pre>
<p>嵌入结构体除了可以复用类型的数据布局，另一个重要的功能是它可以复用类型方法，结构体会自动拥有被嵌入类型的方法，例如：</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

type Sp struct {
    x: i32
}

func Sp.Show {
    println(this.x)
}

type Sc struct {
    Sp
    y: i32
}

func main {
    v := Sc{Sp:Sp{x: 42}, y: 13}
    v.Show() // 42
}
</code></pre>
<blockquote>
<p>在声明嵌入结构体字面量时，不能省略被嵌入结构体名，比如上例中的 <code>Sc{Sp:Sp{x: 42}, y: 13}</code>，如果省略为 <code>{x: 42, y: 13}</code> 将被视为非法。</p>
</blockquote>
<p><code>Sc</code> 中 嵌入 <code>Sp</code> 后，获得了后者的方法，使得 <code>Sc</code> 类型的变量 <code>v</code> 可以执行 <code>Show</code> 操作；在该例中，<code>v.Show()</code> 等价于 <code>v.Sp.Show()</code> 。如果结构体拥有和被嵌结构体同样名称的方法，处理方法与同名成员类似，例如：</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

type Sp struct {
    x: i32
}

func Sp.Show {
    println(this.x)
}

type Sc struct {
    Sp
    x: f32
}

func Sc.Show {
    println(this.x)    
}

func main {
    v := Sc{Sp:Sp{x: 42}, x: 13.14}
    v.Show()    // 13.14
    v.Sp.Show() // 42
}
</code></pre>
<p>为了实现对象复用，凹语言没有采用继承的设计（这与C++不同），而是使用了组合的设计。嵌入结构体就是<strong>组合</strong>的具体表现，嵌入结构体复用了被嵌入类型的内存布局和方法集，与接口（将在第7章介绍）一起，构成了凹语言对象抽象、复用的基础。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="65-匿名结构体"><a class="header" href="#65-匿名结构体">6.5. 匿名结构体</a></h2>
<p>在本章前几节中，我们使用到的结构体都是按以下形式声明的：</p>
<pre><code class="language-wa">type 类型名 struct {
    成员列表
}
</code></pre>
<p>实际上该语法的内在含义是：</p>
<ol>
<li><code>struct {...}</code> 的部分定义了一个结构体；</li>
<li><code>type 类型名</code> 的部分为刚才定义的结构体赋予了一个名字。</li>
</ol>
<p>那么在万余言中，是否可以通过声明结构体字面量的方式直接创建一个结构体变量，而无需对该结构体命名？确实是可以的，这种用法被称为<strong>匿名结构体</strong>，例如：</p>
<pre><code class="language-wa">// 版权 @2021 凹语言 作者。保留所有权利。

//全局匿名结构体变量：
global G: struct{
    name: string
    age: i32
}

func main {
    G.name = &quot;张三&quot;
    G.age = 88
    println(G.name, &quot; &quot;, G.age)  // 张三 88

    //局部匿名结构体变量：
    k := struct {name: string; age: i32}{name: &quot;李四&quot;, age: 66}
    println(k.name, &quot; &quot;, k.age)  // 李四 66

    G = k
    println(G.name, &quot; &quot;, G.age)  // 李四 66
}
</code></pre>
<p>由于匿名结构体没有类型名，因此声明匿名结构体变量时只能使用 <code>变量名: struct{...}</code> 或其快捷定义形式直接指定类型（结构体）。除此之外，匿名结构体以及其成员的使用，与普通的具名结构体基本一致。匿名结构体同样遵循0值初始化规则，其字面值中，未指定初始值的成员均为0值。</p>
<p>匿名结构体最常用的场景是全局配置变量。很多全局配置变量的类型，仅仅在声明该全局变量时会被使用一次，为仅存在一个实例的变量单独定义一个类型略显繁琐，此时即可使用匿名结构体替代（例如上例中的全局变量 <code>G</code>）。</p>
<p>具名类型位于模块的名字空间下，但匿名结构体因为没有名字，其定义实际上位于全局空间，因此内存布局完全一致（既成员个数、对应成员名、对应成员类型均一致）的两个匿名结构体变量，被认为属于同一个类型，可以互相赋值（例如上例中的全局变量 <code>G</code> 和 局部变量 <code>k</code>），哪怕这两个变量位于不同模块中，该特性依然成立；这引出了匿名结构体的另一个使用场景：跨模块传递参数。</p>
<p>由于匿名结构体没有类型名，因此按照语法规则，无法为其添加方法。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="7-接口"><a class="header" href="#7-接口">7. 接口</a></h1>
<p>接口是凹语言抽象的灵魂。在接口之前的凹语言代码都是纯正的写实派，但是有了接口之后就可以通过鸭子类型的面向对象来达到抽象的目的。本章讲述接口的基本用法。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="71-空接口-万能封包器"><a class="header" href="#71-空接口-万能封包器">7.1. 空接口-万能封包器</a></h2>
<p>在凹语言中，最简单的接口是空接口，既 <code>interface {}</code>，声明接口类型变量的方法跟其它类型一致，例如下面的代码声明了一个名为 <code>i</code> 的空接口变量：</p>
<pre><code class="language-wa">    i: interface{}
</code></pre>
<p>习惯上我们一般将 <strong>接口类型变量</strong> 称为 <strong>接口值</strong>。空接口有一个非常独特的特性：<strong>任何类型的值都可以赋值给空接口值</strong>，例如下面的操做全是合法的：</p>
<pre><code class="language-wa">    iface: interface{}

    iface = 777         // 无类型整数赋值给空接口
    iface = 13.14       // 无类型浮点数赋值给空接口
    iface = &quot;你好，空接口&quot; // 字符串赋值给空接口

    i: i64 = 58372665865
    iface = i // 64位整数赋值给空接口

    // 匿名结构体赋值给空接口：
    iface = struct{name: string; age: i32}{name: &quot;凹语言&quot;, age: 1}
</code></pre>
<p>这种赋值行为执行的是传值操作，相当于在接口值内复制了一份原始数据的拷贝，这份拷贝被称为接口值的<strong>具体值</strong>，具体值的类型被称为<strong>具体类型</strong>。</p>
<p>那么如何判断一个已被赋值的接口值所持有的具体类型？如何读取具体值？这就需要用到<strong>类型断言</strong>语法，它的一般形式为：</p>
<pre><code class="language-wa">    v, ok = iface.(Type) // 断言iface的具体类型是否为Type
</code></pre>
<p>其中 <code>v</code> 是类型为 <code>Type</code> 的值， <code>ok</code> 是 <code>bool</code> 型值，该语句执行后，若 <code>ok</code> 为 <code>true</code>，则表明接口值 <code>iface</code> 的具体类型确实是 <code>Type</code>，并且其具体值将被赋予 <code>v</code>；否则表明 <code>iface</code> 的具体类型不为 <code>Type</code>。实际示例如下：</p>
<pre><code class="language-wa">// 版权 @2021 凹语言 作者。保留所有权利。

type T1 struct {
    a: i32
}

func main {
    ival: i32 = 777
    printConcrete(ival)       // i32: 777
    printConcrete(&quot;你好凹语言&quot;) // string: 你好凹语言

    v1 := T1{a: 42}
    printConcrete(v1) // T1, T1.a: 42

    printConcrete(13.14) // 未知类型
}

func printConcrete(iface: interface{}) {
    ok: bool
    i: i32
    s: string
    t: T1

    i, ok = iface.(i32)
    if ok {
        println(&quot;i32:&quot;, i)
        return
    }

    s, ok = iface.(string)
    if ok {
        println(&quot;string:&quot;, s)
        return
    }

    t, ok = iface.(T1)
    if ok {
        println(&quot;T1, T1.a:&quot;, t.a)
        return
    }

    println(&quot;未知类型&quot;)
}
</code></pre>
<p>在函数 <code>printConcrete</code> 内，通过接口类型断言，可以动态的判断传入的空接口值的具体类型，并获取其具体值。由于函数内未进行浮点数断言，因此输入浮点数时会输出“未知类型”。</p>
<p>注意函数 <code>printConcrete</code> 的参数类型为空接口（<code>interface{}</code>），在 <code>main</code> 函数中调用它时，实际上执行了隐式转换（拷贝），比如语句 <code>printConcrete(ival)</code> 实际上等价于：</p>
<pre><code class="language-wa">    iface: interface{} = ival
    printConcrete(iface)
</code></pre>
<blockquote>
<p>凹语言在绝大多数情况下不允许隐式类型转换，但接口是个例外。当函数参数类型为接口时，若调用方填入的实参是具体类型，则编译器会自动执行赋值转换的操作。</p>
</blockquote>
<p>如果接口值的具体类型存在多种可能，那么使用多个类型断言加条件判断的方法无疑很累赘，在这种场景下，可以使用<code>switch...case...</code>格式的分支类型断言，例如上述 <code>printConcrete</code> 函数可以改写为：</p>
<pre><code class="language-wa">func printConcrete(iface: interface{}) {
	//分支类型断言
    switch v := iface.(type) {
    case i32:
        println(&quot;i32:&quot;, v)  // v是iface的具体值，该分支下，其类型为 i32，下同

    case string:
        println(&quot;string:&quot;, v)

    case T1:
        println(&quot;T1, T1.a:&quot;, v.a)

    default:
        println(&quot;未知类型&quot;)
    }
}
</code></pre>
<p>其中 <code>iface.(type)</code> 是固定写法，后续每个 <code>case</code> 分支表示具体类型满足该分支条件。</p>
<p>任何类型的值都可以赋予空接口，它在凹语言中实际起到了万能封包器的作用，经常用于在函数间传递类型会动态变化的值。</p>
<blockquote>
<p>本文中“<strong>空接口</strong>”指 <code>interface{}</code>，既方法集为空的接口类型，下一节中的“<strong>非空接口</strong>”指方法集不为空的接口类型；当我们要描述值为0的接口值时，将使用“<strong>0值接口</strong>”，或“<strong>nil接口</strong>”，请注意区分。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="72-非空接口"><a class="header" href="#72-非空接口">7.2. 非空接口</a></h2>
<p>接口是方法的集合，接口声明的一般形式如下：</p>
<pre><code class="language-wa">type 接口名 interface {
    方法集合
}
</code></pre>
<p>在<code>方法集合</code>中方法，其属性包括方法名以及方法的函数签名，比如我们定义一个接口如下：</p>
<pre><code class="language-wa">type Stringer interface {
    String() =&gt; string
}
</code></pre>
<p>该接口名为 <code>Stringer</code>，其中包含一个名为 <code>String</code> 的方法，该方法没有输入参数，返回值为字符串。</p>
<p>如果一个具体类型 <code>T</code> 的方法集合，是某个接口 <code>I</code> 的方法集合 MethodSet_i的超集，那么我们称：<strong>类型 <code>T</code> 满足接口 <code>I</code></strong>。换句话说，设类型 <code>T</code> 的方法集合为 <code>St</code>，接口 <code>I</code> 的方法集合为 <code>Si</code>，类型 <code>T</code> 满足接口 <code>I</code> 的充要条件是：任取 <code>m ∈ Si</code>，存在 <code>m' ∈ St</code>，使得 <code>m</code> 与 <code>m'</code> 的名字相同，且函数签名相同。</p>
<p><strong>如果类型 <code>T</code> 满足接口 <code>I</code>，那么类型为 <code>T</code> 的值将可以被赋值给 <code>I</code> 型的接口值</strong>，在执行赋值操作时，类型 <code>T</code> 的值将被拷贝至接口值内部；这也是上一节中，空接口是万能封包器的由来，因为按照上述定义，<code>interface{}</code> 的方法集为空，任何类型都满足它。</p>
<p>接口方法可以被调用，其调用将动态切至接口值内部所包含的具体值的同名方法（如果接口值内部所包含的具体值为nil，那么调用将触发运行时异常）。非空接口是凹语言中重要的抽象手段。不同类型的对象可以满足同一个接口，使得调用者可以通过接口，按照统一的方式使用不同类型的对象，因此接口作用的本质，是一组方法约定，该约定的检查（具体类型是否满足某个接口），是编译时完成的。下面是一个具体的例子：</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

type Printer interface {
    Print()
}

type T1 struct {
    i: i32
}

func T1.Print {
    println(&quot;This is T1, this.i:&quot;, this.i)
}

type T2 struct {
    s: string
}

func T2.Print {
    println(&quot;This is T2, this.s:&quot;, this.s)
}

func PrintObj(p: Printer) {
    p.Print()
}

func main {
    p: Printer

    v1: T1
    v1.i = 42
    p = &amp;v1
    PrintObj(p) // This is T1, this.i: 42

    v2: T2
    v2.s = &quot;你好&quot;
    p = &amp;v2
    PrintObj(p) // This is T2, this.s: 你好
}
</code></pre>
<p>由此可见，同一个接口值 <code>p</code> 中封装了不同的对象时，使用同样的方法使用它，其行为也会随着对象类型的不同发生变化。</p>
<p>由于具名类型本身无法拥有方法，而只有其引用才能拥有方法（参考6.2节），因此上例中，<code>v1</code> 不能赋值给 <code>p</code>，而只有其引用 <code>&amp;v1</code> 方可。如果试图将 <code>v1</code> 赋值给 <code>p</code>，将会引发编译错误。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="73-类型断言总结"><a class="header" href="#73-类型断言总结">7.3. 类型断言总结</a></h2>
<p>7.1节介绍了如何从类型为 <code>interface{}</code> 的接口值中通过类型断言获取它所包含的具体值，该用法对于非空接口值依然成立，例如：</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

type Printer interface {
    Print()
}

type T1 struct {
    i: i32
}

func T1.Print { println(&quot;This is T1, this.i:&quot;, this.i) }

type T2 struct {
    s: string
}

func T2.Print { println(&quot;This is T2, this.s:&quot;, this.s) }

func doConcrete(p: Printer) {
    switch v := p.(type) {
    case *T1:
        v.Print() // 方法直接调用，而非接口调用

    case *T2:
        v.Print()
    }
}

func main {
    v1 := T1{i: 42}
    doConcrete(&amp;v1) // This is T1, this.i: 42

    v2 := T2{s: &quot;hello&quot;}
    doConcrete(&amp;v2) // This is T2, this.s: hello
}
</code></pre>
<p>注意函数 <code>doConcrete</code> 中 <code>v.Print()</code> 是直接调用，而非接口调用，因为在 <code>case *T1</code> 分支中，<code>v</code> 的类型是 <code>*T1</code>。另外，非空接口值也可以通过 <code>v, ok = iface.(Type)</code> 形式进行具体类型断言，这与7.1节中空接口值的对应用法一致。</p>
<p>实际上类型断言的用法还不仅于此，在某些情况下，一个具体类型 <code>*T</code> 可能同时满足多个接口 <code>I1</code>、<code>I2</code>，那么当一个 <code>I1</code> 的接口值中包含的具体值类型为 <code>*T</code> 时，可以在该接口值上通过类型断言，直接获取一个类型为 <code>I2</code> 的接口值，例如：</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

type I1 interface {
    f1()
}

type I2 interface {
    f2()
}

type T struct {
    i: i32
}

func T.f1 { println(&quot;T.f1(), T.i:&quot;, this.i) }

func T.f2 { println(&quot;T.f2(), T.i:&quot;, this.i) }

func main {
    v1 := T{i: 42}

    i1: I1 = &amp;v1
    i1.f1() // T.f1(), T.i: 42

    i2, ok := i1.(I2) // 断言为另一个接口
    if ok {
        i2.f2() // T.f2(), T.i: 42
    }
}
</code></pre>
<p>这种用法一般常见于从 <code>interface{}</code> 接口值中获取非空接口。</p>
<p>除了形如 <code>v, ok = iface.(Type)</code> 的类型断言外，还有另一种模式的类型断言：</p>
<pre><code class="language-wa">    v = iface.(Type)
</code></pre>
<p>该模式取消了操作成功标志的返回值 <code>ok</code>，只返回被断言类型的值。如果类型断言失败，则会触发运行时异常，建议仅在完全确认断言不会失败的情况下才使用该模式。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="74-接口的其它特性"><a class="header" href="#74-接口的其它特性">7.4. 接口的其它特性</a></h2>
<p>在声明接口时，接口的方法集可以包含另一个接口，例如：</p>
<pre><code class="language-wa">type I1 interface {
    f1()
}

type I2 interface {
    I1
    f2()
}
</code></pre>
<p>使用该形式，编译器会将接口 <code>I1</code> 的方法拷贝至 <code>I2</code> 的方法集中，这与直接在 <code>I2</code> 的方法集中增加 <code>f1()</code> 是等价的。</p>
<p>如果接口 <code>I2</code> 的方法集是接口 <code>I1</code> 方法集的真超集，我们称“与I1相比，I2是小接口”，这一说法看起来有些反直觉，其内在逻辑在于：接口是方法合约，由于 <code>I2</code> 中的方法更多，因此满足 <code>I2</code> 的类型的集合，一定是满足 <code>I1</code> 的类型的集合的子集——或者说满足 <code>I2</code> 的类型少等于满足<code>I1</code>的类型。从这个角度来说，空接口（<code>interface{}</code>）是最大的接口，非空接口中所包含的方法越多，接口倾向于越小。</p>
<p>我们也可以声明匿名接口值，匿名接口各方面都与匿名结构体类似，它们都位于全局名字空间（可跨模块使用）。</p>
<p>接口调用比具体类型直接调用略慢，因此没有必要为只有一种类型满足的行为（或者说方法集）创建接口。</p>
<p>接口值是可比的，只有同时满足以下条件，两个非nil接口值 <code>i1</code>、<code>i2</code> 才相等（既表达式 <code>i1==i2</code> 为 <code>true</code>）：</p>
<ul>
<li><code>i1</code> 的具体类型与 <code>i2</code> 的具体类型相同，且该类型可比</li>
<li><code>i1</code> 的具体值与 <code>i2</code> 的具体值相等</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="附录"><a class="header" href="#附录">附录</a></h1>
<p>附录包含语法规范简介和标准库简介。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="a-语法规范"><a class="header" href="#a-语法规范">A. 语法规范</a></h2>
<p>这里是简化的凹语言语法规范，主要是作为理解参考。</p>
<h3 id="a1-文件结构"><a class="header" href="#a1-文件结构">A.1 文件结构</a></h3>
<p>凹语言是一个精心设计的语言，语法非常利于理解和解析。一个凹语言文件中，顶级的语法元素只有5种：import、type、const、var以及fn。每个文件的语法规范定义如下：</p>
<pre><code>SourceFile    = { ImportDecl &quot;;&quot; } { TopLevelDecl &quot;;&quot; } .

TopLevelDecl  = Declaration | FuncDecl | MethodDecl .
Declaration   = ConstDecl | TypeDecl | GlobalDecl .
</code></pre>
<p>SourceFile表示一个凹源文件，由以下两个部分组成：ImportDec（导入声明）和TopLevelDecl（顶级声明）。其中TopLevelDecl由通用声明、函数声明和方法声明组成，通用声明再分为常量、类型和变量声明。</p>
<p>导入语法如下：</p>
<pre><code>ImportDecl  = &quot;import&quot; ( ImportSpec | &quot;(&quot; { ImportSpec &quot;;&quot; } &quot;)&quot; ) .
ImportSpec  = ImportPath [ &quot;=&gt;&quot; PackageName ] .
ImportPath  = string_lit .

PackageName = identifier .
</code></pre>
<p>imort 关键字用于导入包，导入的包还可以被重新命名（对应PackageName）。</p>
<p>以下代码是一个凹源文件的对应例子：</p>
<pre><code>// 凹语言例子

import (&quot;a&quot;, &quot;b&quot;)

type SomeType int
const PI = 3.14
global Length = 1 // 全局变量

func main {
    sum: int // 局部变量
    println(sum)
}
</code></pre>
<p>只要通过每行开头的不同关键字就可以明确属于那种声明类型。</p>
<h3 id="a2-函数和方法"><a class="header" href="#a2-函数和方法">A.2 函数和方法</a></h3>
<p>函数是所有编程语言中的核心，因为只有函数的语句才有了计算的功能。凹语言的函数也是一种值数据，可以定义包级别的函数，也可以为自定义的类型定义方法，同时还可以在局部作用域内定义闭包函数。在顶级声明中包含函数和方法的声明，从语法角度看函数是没有接收者参数的方法特例。</p>
<p>函数的语法规则如下：</p>
<pre><code>FuncDecl     = &quot;func&quot; MethodName [ Signature ] [ FnBody ] .
MethodDecl = &quot;func&quot; Receiver &quot;.&quot; MethodName [ Signature ] [ FnBody ] .

MethodName     = identifier .
Receiver       = identifier .
Signature      = Parameters [ &quot;=&gt;&quot; Result ] .
Result         = Parameters | &quot;:&quot; Type .
Parameters     = &quot;(&quot; [ ParameterList [ &quot;,&quot; ] ] &quot;)&quot; .
ParameterList  = ParameterDecl { &quot;,&quot; ParameterDecl } .
ParameterDecl  = [ IdentifierList ] &quot;:&quot; [ &quot;...&quot; ] Type .
</code></pre>
<p>其中FnDecl表示函数，而MethodDecl表示方法。MethodDecl表示的方法规范比函数多了Receiver语法结构，Receiver表示方法的接收者参数。然后是MethodName表示的函数或方法名，Signature表示函数的签名（或者叫类型），最后是函数的主体。需要注意的是函数的签名只有输入参数和返回值部分，因此函数或方法的名字、以及方法的接收者类型都不是函数签名的组成部分。从以上定义还可以发现，Receiver、Parameters和Result都是ParameterList定义，因此有着相同的语法结构（在语法树中也是有着相同的结构）。</p>
<p>下面是函数和方法的常见形式：</p>
<pre><code># 函数声明
func()
func(x :int) =&gt; int
func(a, _ :int, z :f32) =&gt; bool
func(a, b :int, z :f32) =&gt; (bool)
func(prefix :string, values :...int)
func(a, b :int, z :f64, opt :...any) =&gt; (success bool)
func(int, int, f64) =&gt; (f64, *[]int)
func(n :int) =&gt; func(p :*T)

# 方法定义
func Person.GetName() =&gt; string { return this.name }
</code></pre>
<h3 id="a3-关键字和运算符"><a class="header" href="#a3-关键字和运算符">A.3 关键字和运算符</a></h3>
<p>关键字是语法的组成元素，不能用于标识符。凹语言目前有19个关键字：</p>
<pre><code>break     defer  import     struct
case      else   interface  switch
const     for    map        type
continue  func   range      global
default   if     return
</code></pre>
<p>以下是凹语言的运算符和与标点：</p>
<pre><code>+    &amp;     +=    &amp;=     &amp;&amp;    ==    !=    (    )
-    |     -=    |=     ||    &lt;     &lt;=    [    ]
*    ^     *=    ^=     &lt;-    &gt;     &gt;=    {    }
/    &lt;&lt;    /=    &lt;&lt;=    ++    =     :=    ,    ;
%    &gt;&gt;    %=    &gt;&gt;=    --    !     ...   .    :
     &amp;^          &amp;^=                      =&gt;
</code></pre>
<p>运算符用于组成表达式，标点用于组成或分隔语句。</p>
<h3 id="a4-数据类型"><a class="header" href="#a4-数据类型">A.4 数据类型</a></h3>
<p>除了布尔类型、字符、整数、浮点数、字符串等基础类型，凹语言还提供了指针、数组、切片、结构体、map、函数和接口等复合类型。复合类型的语法定义如下：</p>
<pre><code>TypeDecl  = &quot;type&quot; ( TypeSpec | &quot;(&quot; { TypeSpec &quot;;&quot; } &quot;)&quot; ) .
TypeSpec  = AliasDecl | TypeDef .

AliasDecl = identifier &quot;=&quot; Type .
TypeDef   = identifier &quot;:&quot; Type .

Type      = TypeName | TypeLit | &quot;(&quot; Type &quot;)&quot; .
TypeName  = identifier | PackageName &quot;.&quot; identifier .
TypeLit   = PointerType | ArrayType | SliceType
          | StructType | MapType | FnType | InterfaceType
          .
</code></pre>
<p>其中TypeDecl定义了类型声明的语法规范，可以是每个类型独立定义或通过小括弧包含按组定义。其中AliasDecl是定义类型的别名（名字和类型中间有个赋值符号），而TypeDef则是定义一个新的类型。而基础的Type就是由标识符或者是小括弧包含的其它类型表示。TypeName不仅仅可以从当前空间的标识符定义新类型，还支持从其它包导入的标识符定义类型。而TypeLit表示类型面值，比如基于已有类型的指针，或者是匿名的结构体都属于类型的面值。</p>
<p>下面以结构体为例展示复合类型的语法：</p>
<pre><code>StructType     = &quot;struct&quot; &quot;{&quot; { FieldDecl &quot;;&quot; } &quot;}&quot; .
FieldDecl      = (IdentifierList &quot;:&quot; Type | EmbeddedField) [ Tag ] .
EmbeddedField  = [ &quot;*&quot; ] TypeName .
Tag            = string_lit .

IdentifierList = identifier { &quot;,&quot; identifier } .
TypeName       = identifier | PackageName &quot;.&quot; identifier .
</code></pre>
<p>结构体通过struct关键字开始定义，然后在大括弧中包含成员的定义。每一个FieldDecl表示一组有着相同类型和Tag字符串的标识符名字，或者是嵌入的匿名类型或类型指针。</p>
<p>以下是结构体的例子：</p>
<pre><code>type MyStruct struct {
    a, b : int &quot;int value&quot;
    string
}
</code></pre>
<p>其中a和b成员不仅仅有着相同的int类型，同时还有着相同的Tag字符串，最后的成员是嵌入一个匿名的字符串。</p>
<h3 id="a5-语句块和语句"><a class="header" href="#a5-语句块和语句">A.5 语句块和语句</a></h3>
<p>语句近似看作是函数体内可独立执行的代码，语句块是由大括弧定义的语句容器，语句块和语句只能在函数体内部定义。语句块和语句是在函数体部分定义，函数体就是一个语句块。语句块的语法规范如下：</p>
<pre><code>FnBody  = Block .

Block         = &quot;{&quot; StatementList &quot;}&quot; .
StatementList = { Statement &quot;;&quot; } .

Statement     = Declaration | ExpressionStmt
              | IfStmt | Block | ReturnStmt
              | ForStmt | BreakStmt | ContinueStmt
              .
</code></pre>
<p>FnBody函数体对应一个Block语句块。每个Block语句块内部由多个语句列表StatementList组成，每个语句之间通过分号分隔。语句又可分为声明语句、标签语句、普通表达式语句和其它诸多控制流语句。需要注意的是，Block语句块也是一种合法的语句，因此函数体实际上是又Block组成的多叉树结构表示，每个Block结点又可以递归保存其他的可嵌套Block的控制流等语句。</p>
<p>其中声明语句和表达式语句语法如下（声明语句的细节可参考语言文档，这里不做展开）：</p>
<pre><code>Declaration  = ConstDecl | TypeDecl | GlobalDecl .
TopLevelDecl = Declaration | FuncDecl | MethodDecl .

ExpressionStmt = Expression .
</code></pre>
<p>下面是声明语句和表达式语句的例子：</p>
<pre><code>const Pi = 3.14
type MyInt int32
global x = 123 // 全局变量

x = x + 1
</code></pre>
<p>if 和 return 语句的语法定义如下：</p>
<pre><code>IfStmt         = &quot;if&quot; [ SimpleStmt &quot;;&quot; ] Expression Block [ &quot;else&quot; ( IfStmt | Block ) ] .
ReturnStmt     = &quot;return&quot; [ ExpressionList ] .
ExpressionList = Expression { &quot;,&quot; Expression } .
</code></pre>
<p>if 和 return 语句的例子如下：</p>
<pre><code>func main {
    if 1+1 == 2 { return }
}
</code></pre>
<p>for 循环语句的语法定义如下：</p>
<pre><code>ForStmt     = &quot;for&quot; [ Condition | ForClause | RangeClause ] Block .

Condition   = Expression .

ForClause   = [ InitStmt ] &quot;;&quot; [ Condition ] &quot;;&quot; [ PostStmt ] .
InitStmt    = SimpleStmt .
PostStmt    = SimpleStmt .

RangeClause = [ ExpressionList &quot;=&quot; | IdentifierList &quot;:=&quot; ] &quot;range&quot; Expression .
</code></pre>
<p>循环的例子如下：</p>
<pre><code>for {}          # 死循环
for true {}     # 死循环
for ; true ; {} # 死循环

# C 语言风格循环
for i := 0; i &lt; 10; i++ {}

# 循环迭代列表的元素
list := make([]int, 10)
for i, v := range list {}
</code></pre>
<p>基于声明、定义、分支、循环这些基本的语句，就可以构造出任意复杂的程序。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="b-标准库"><a class="header" href="#b-标准库">B. 标准库</a></h2>
<p>包含 apple、builtin、errors、regexp、runtime、syscall 等包的简要说明。</p>
<h3 id="b1-apple---苹果派"><a class="header" href="#b1-apple---苹果派">B.1 apple - 苹果派</a></h3>
<p>apple 包用于展示最简单的包和测试的构造。</p>
<h4 id="b11-函数"><a class="header" href="#b11-函数">B.1.1 函数</a></h4>
<pre><code class="language-wa">func Apple =&gt; string
</code></pre>
<ul>
<li>Apple 返回苹果的字符串</li>
</ul>
<h3 id="b2-builtin---内置包"><a class="header" href="#b2-builtin---内置包">B.2 builtin - 内置包</a></h3>
<p>凹语言中 <code>bool</code>、<code>int</code>、<code>string</code> 和 <code>println</code> 等都不是关键字，而是编译器内置的包定义。<code>builtin</code> 包中定义的名字都是小写字母开头，不需要 <code>import</code> 就可以使用。</p>
<h4 id="b21-类型"><a class="header" href="#b21-类型">B.2.1 类型</a></h4>
<ul>
<li>bool：布尔类似</li>
<li>u8：8比特无符号整数</li>
<li>u16：16比特无符号整数</li>
<li>u32：32比特无符号整数</li>
<li>u64：64比特无符号整数</li>
<li>i32：32比特有符号整数</li>
<li>i64：64比特有符号整数</li>
<li>int：有符号整数</li>
<li>uint；无符号整数</li>
<li>f32：IEEE754 单精度浮点数</li>
<li>f64：IEEE754 双精度浮点数</li>
<li>string：UTF8 编码的字符串</li>
<li>rune：字符，底层为 i32</li>
<li>byte：字节，底层为 u8</li>
<li>error：错误接口</li>
</ul>
<h4 id="b22-常量"><a class="header" href="#b22-常量">B.2.2 常量</a></h4>
<ul>
<li>nil：空引用，可以用于切片、接口的比较。</li>
</ul>
<h4 id="b23-函数"><a class="header" href="#b23-函数">B.2.3 函数</a></h4>
<pre><code class="language-wa">func print(args: ...Type)
func println(args: ...Type)

func new(Type) =&gt; *Type
func make(t: Type, size: ...IntegerType) =&gt; Type

func len(v: Type) =&gt; int
func cap(v: Type) =&gt; int

func append(slice: []Type, elems: ...Type) =&gt; []Type
func copy(dst, src: []Type) =&gt; int

func panic(msg: string)
</code></pre>
<ul>
<li>print：打印基础类型</li>
<li>println：打印基础类型并换行</li>
<li>new：创新一个 Type 的实体并返回引用</li>
<li>make：创建切片，并返回引用</li>
<li>len：获取数组、切片、字符串等类型值的元素长度</li>
<li>cap：获取数组、切片的容量</li>
<li>append：向切片添加元素</li>
<li>copy：赋值切片</li>
<li>panic：泡出异常</li>
</ul>
<h3 id="b3-errors---错误包"><a class="header" href="#b3-errors---错误包">B.3 errors - 错误包</a></h3>
<p>errors 包用于创新一个可以表示字符串信息的错误对象。</p>
<h4 id="b31-函数"><a class="header" href="#b31-函数">B.3.1 函数</a></h4>
<pre><code class="language-wa">func New(text: string) =&gt; error
</code></pre>
<ul>
<li>New 创建一个错误对象</li>
</ul>
<h3 id="b4-regexp---正则包"><a class="header" href="#b4-regexp---正则包">B.4 regexp - 正则包</a></h3>
<p>正则包是 Rob Pike 最小正则实现：<a href="https://www.cs.princeton.edu/courses/archive/spr09/cos333/beautiful.html">https://www.cs.princeton.edu/courses/archive/spr09/cos333/beautiful.html</a></p>
<h4 id="b41-函数"><a class="header" href="#b41-函数">B.4.1 函数</a></h4>
<pre><code class="language-wa">func Match(regexp, text: string) =&gt; bool
</code></pre>
<h3 id="b5-runtime---运行时包"><a class="header" href="#b5-runtime---运行时包">B.5 runtime - 运行时包</a></h3>
<p>凹语言运行时类型和函数的实现。</p>
<h4 id="b51-常量"><a class="header" href="#b51-常量">B.5.1 常量</a></h4>
<pre><code class="language-wa">const WAOS = &quot;...&quot;
</code></pre>
<ul>
<li>WAOS：凹语言目标OS名字，目前有 wasi、mvp 等</li>
</ul>
<h3 id="b6-syscall---系统调用包"><a class="header" href="#b6-syscall---系统调用包">B.6 syscall - 系统调用包</a></h3>
<p>凹语言不同目标平台提供的系统调用。通常是 runtime 或其他包封装 syscall 包的函数。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
