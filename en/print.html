<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Wa-lang&#x27;s Manual</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Wa-lang&#x27;s Manual">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Wa-lang's manual</a></li><li class="chapter-item expanded affix "><a href="preface.html">Preface</a></li><li class="chapter-item expanded "><a href="1.InstallAndGetStart/index.html"><strong aria-hidden="true">1.</strong> 1.Install And Get Start</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="1.InstallAndGetStart/1.1.HelloWorld.html"><strong aria-hidden="true">1.1.</strong> hello world</a></li><li class="chapter-item expanded "><a href="1.InstallAndGetStart/1.2.Install.html"><strong aria-hidden="true">1.2.</strong> Install Wa-lang Compiler</a></li><li class="chapter-item expanded "><a href="1.InstallAndGetStart/1.3.Command.html"><strong aria-hidden="true">1.3.</strong> wa command line</a></li><li class="chapter-item expanded "><a href="1.InstallAndGetStart/1.4.ProjectStructure.html"><strong aria-hidden="true">1.4.</strong> Project directory structure</a></li><li class="chapter-item expanded "><a href="1.InstallAndGetStart/1.5.Plugins.html"><strong aria-hidden="true">1.5.</strong> Plug-ins for IDE</a></li></ol></li><li class="chapter-item expanded "><a href="2.ProgramStructure/index.html"><strong aria-hidden="true">2.</strong> Program structure</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2.ProgramStructure/2.1.GlobalDeclaration.html"><strong aria-hidden="true">2.1.</strong> Global declaration</a></li><li class="chapter-item expanded "><a href="2.ProgramStructure/2.2.GlobalVariableDeclaration.html"><strong aria-hidden="true">2.2.</strong> Global variable declaration</a></li><li class="chapter-item expanded "><a href="2.ProgramStructure/2.3.FunctionDeclaration.html"><strong aria-hidden="true">2.3.</strong> Function declaration</a></li><li class="chapter-item expanded "><a href="2.ProgramStructure/2.4.ConstDeclaration.html"><strong aria-hidden="true">2.4.</strong> Constant declaration</a></li><li class="chapter-item expanded "><a href="2.ProgramStructure/2.5.ImportDeclaration.html"><strong aria-hidden="true">2.5.</strong> Import declaration</a></li></ol></li><li class="chapter-item expanded "><a href="3.BasicTypes/index.html"><strong aria-hidden="true">3.</strong> Basic types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3.BasicTypes/3.1.LocalVariableDeclaration.html"><strong aria-hidden="true">3.1.</strong> Local variable declaration</a></li><li class="chapter-item expanded "><a href="3.BasicTypes/3.2.Integers.html"><strong aria-hidden="true">3.2.</strong> Integers</a></li><li class="chapter-item expanded "><a href="3.BasicTypes/3.3.FloatingPointNumbers.html"><strong aria-hidden="true">3.3.</strong> Floating point number</a></li><li class="chapter-item expanded "><a href="3.BasicTypes/3.4.String.html"><strong aria-hidden="true">3.4.</strong> String</a></li></ol></li><li class="chapter-item expanded "><a href="4.Function/index.html"><strong aria-hidden="true">4.</strong> Function</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="4.Function/4.1.FunctionCall.html"><strong aria-hidden="true">4.1.</strong> Function call</a></li><li class="chapter-item expanded "><a href="4.Function/4.2.FunctionValues.html"><strong aria-hidden="true">4.2.</strong> Function values</a></li><li class="chapter-item expanded "><a href="4.Function/4.3.AnonymousFunctionsAndClosures.html"><strong aria-hidden="true">4.3.</strong> Anonymous functions and closures</a></li><li class="chapter-item expanded "><a href="4.Function/4.4.ifStatements.html"><strong aria-hidden="true">4.4.</strong> if statements</a></li><li class="chapter-item expanded "><a href="4.Function/4.5.forStatements.html"><strong aria-hidden="true">4.5.</strong> for statements</a></li><li class="chapter-item expanded "><a href="4.Function/4.6.switchStatements.html"><strong aria-hidden="true">4.6.</strong> switch statements</a></li></ol></li><li class="chapter-item expanded "><a href="5.CompositeTypes/index.html"><strong aria-hidden="true">5.</strong> Composite types</a></li><li class="chapter-item expanded "><a href="6.CustomTypes/index.html"><strong aria-hidden="true">6.</strong> Custom types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="6.CustomTypes/6.1.Structure.html"><strong aria-hidden="true">6.1.</strong> Structure</a></li><li class="chapter-item expanded "><a href="6.CustomTypes/6.2.Method.html"><strong aria-hidden="true">6.2.</strong> Method</a></li><li class="chapter-item expanded "><a href="6.CustomTypes/6.3.MethodValues.html"><strong aria-hidden="true">6.3.</strong> Method values</a></li><li class="chapter-item expanded "><a href="6.CustomTypes/6.4.EmbeddedStructure.html"><strong aria-hidden="true">6.4.</strong> Embedded structure</a></li><li class="chapter-item expanded "><a href="6.CustomTypes/6.5.AnonymousStructure.html"><strong aria-hidden="true">6.5.</strong> Anonymous structure</a></li></ol></li><li class="chapter-item expanded "><a href="7.Interface/index.html"><strong aria-hidden="true">7.</strong> Interface</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="7.Interface/7.1.NullInterface.html"><strong aria-hidden="true">7.1.</strong> Null interface - universal wrapper</a></li><li class="chapter-item expanded "><a href="7.Interface/7.2.Non-nullInterface.html"><strong aria-hidden="true">7.2.</strong> Non-null interface</a></li><li class="chapter-item expanded "><a href="7.Interface/7.3.TypeAssertions.html"><strong aria-hidden="true">7.3.</strong> Summary of type assertions</a></li><li class="chapter-item expanded "><a href="7.Interface/7.4.OtherFeatures.html"><strong aria-hidden="true">7.4.</strong> Other features of interface</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Wa-lang&#x27;s Manual</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/wa-lang/man" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="wa-langs-manual"><a class="header" href="#wa-langs-manual">Wa-lang's Manual</a></h1>
<p><img src="cover.png" alt="" /></p>
<ul>
<li>Online manual：<a href="https://wa-lang.github.io/man/en/">https://wa-lang.github.io/man/en/</a></li>
<li>Online manual(Chinese)：<a href="https://wa-lang.org/man/">https://wa-lang.org/man/</a></li>
<li>Github Repo: <a href="https://github.com/wa-lang/man">https://github.com/wa-lang/man</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p><em>The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: <a href="https://github.com/wa-lang/man/tree/master/en">https://github.com/wa-lang/man/tree/master/en</a></em></p>
<h1 id="preface"><a class="header" href="#preface">Preface</a></h1>
<p>The Wa-lang is a general statically typed compiled language designed for the WebAssembly platform. It is a project initiated by a group of programming language enthusiasts in China, and its design focuses on reducing the mental burden on users.</p>
<p>The project was established at the end of 2018, and preliminary preparations began in 2019. New members will be added in 2020. In 2021, the project co-founders publish a book <a href="https://github.com/chai2010/go-ast-book">《Go语言定制指南》(&quot;Go Language Customization Guide&quot;)</a>, the project was officially launched in 2022 and open sourced on July 20. Wa-lang is taking one step at a time. Among similar projects in China, it is the first to accomplish compilation and execution in web page.</p>
<p>On the first anniversary of open source, Wa-lang released <a href="https://github.com/wa-lang/wa/releases">MVP version</a> on August 12 (MVP means &quot;Minimum Viable Product&quot;). We hope that the release of the MVP version will allow everyone to try and explore more and imagine more possibilities for future development.</p>
<p>Finally, thanks to the support of Chinese programming language enthusiasts, the Wa-lang MVP version is a new starting point. Everyone is welcome to participate in the co-construction!</p>
<div style="break-before: page; page-break-before: always;"></div><p><em>The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: https://github.com/wa-lang/man/tree/master/en</em></p>
<h1 id="1-install-and-get-start"><a class="header" href="#1-install-and-get-start">1. Install and get start</a></h1>
<p>This chapter describes the simplest Wa-lang example, how to install the Wa-lang compiler, plug-ins for IDE, project directory structure and command line functions, etc.</p>
<div style="break-before: page; page-break-before: always;"></div><p><em>The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: <a href="https://github.com/wa-lang/man/tree/master/en">https://github.com/wa-lang/man/tree/master/en</a></em></p>
<h2 id="11-hello-world"><a class="header" href="#11-hello-world">1.1. hello world</a></h2>
<p>Printing &quot;hello world&quot; is a common example for PL. The Wa-lang example prints &quot;你好，凹语言！&quot; in Chinese, means &quot;Hello, Wa-lang&quot;.</p>
<h3 id="111-你好凹语言"><a class="header" href="#111-你好凹语言">1.1.1 你好，凹语言！</a></h3>
<p>Create hello.wa file with the following content:</p>
<pre><code class="language-wa">// 版权 @2019 凹语言 作者。保留所有权利。

import &quot;fmt&quot;
import &quot;runtime&quot;

global year: i32 = 2023

func main {
    println(&quot;你好，凹语言！&quot;, runtime.WAOS)
    println(add(40, 2), year)

    fmt.Println(&quot;1+1 =&quot;, 1+1)
}

func add(a: i32, b: i32) =&gt; i32 {
    return a+b
}
</code></pre>
<p>Among them, <code>//</code> starts with a line comment, the <code>import</code> keyword imports two packages of the standard library, and the <code>global</code> keyword defines a global variable and gives an initial value of 2023. The <code>func</code> keyword defines the <code>main</code> function and the <code>add</code> function. The <code>main</code> function is the entry point of the program, which prints &quot;你好，凹语言！&quot; through the built-in <code>println</code> function, while using the <code>Println</code> string and integer expression results of the <code>fmt</code> package. The global <code>year</code> variable is also used in the <code>main</code> function. In addition, the <code>add</code> function is called and the return value is printed. The <code>add</code> function has 2 input parameters and a return value.</p>
<p>If the <code>wa</code> command of the Wa-lang has been installed locally (refer to Section 1.2 for the installation), you can enter the following command to execute:</p>
<pre><code>$ wa run hello.wa 
你好，凹语言！ wasi
42
1+1 = 2
</code></pre>
<h3 id="112-playground-online"><a class="header" href="#112-playground-online">1.1.2 Playground online</a></h3>
<p>The Wa-lang is a general-purpose programming language designed for WebAssembly. From its inception, the browser has been the first support target. Playground can be accessed through <a href="https://wa-lang.org/playground">https://wa-lang.org/playground</a>. The interface is as follows:</p>
<p><img src="1.InstallAndGetStart/./images/playground-01.png" alt="" /></p>
<p>Click the &quot;RUN&quot; button to see the output results.</p>
<hr />
<p>Known issues:</p>
<ul>
<li>The online playground only supports single file mode and does not support multi-file project mode yet. This problem does not affect syntax compatibility. Subsequent corrections to this problem will not affect the existing source code. Developers using Wa-lang do not need to deal with this issue specially.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p><em>The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: <a href="https://github.com/wa-lang/man/tree/master/en">https://github.com/wa-lang/man/tree/master/en</a></em></p>
<h2 id="12-install-wa-lang-compiler"><a class="header" href="#12-install-wa-lang-compiler">1.2. Install Wa-lang Compiler</a></h2>
<p>In addition to accessing the online Wa-lang playground, you can also install the compiler locally.</p>
<h3 id="121-install-binaries"><a class="header" href="#121-install-binaries">1.2.1 Install binaries</a></h3>
<p>Download the latest binaries from Github: <a href="https://github.com/wa-lang/wa/releases">https://github.com/wa-lang/wa/releases</a>. You need to ensure that it corresponds to the local platform. For example, on macOS/amd64, <a href="https://github.com/wa-lang/wa/releases/download/v0.8.1/wa_0.8.1_darwin_amd64.tar.gz">wa_0.8.1_darwin_amd64.tar.gz</a> should be used.</p>
<p>The contents of the directory after decompression are as follows:</p>
<pre><code>$ tree ./wa_0.8.1_darwin_amd64
./wa_0.8.1_darwin_amd64
├── LICENSE
├── README-zh.md
├── README.md
└── wa

1 directory, 5 files
</code></pre>
<p>Add the directory path to the system's <code>PATH</code> environment, then reopen the command line environment and execute the <code>wa -v</code> command to view the version information.</p>
<pre><code>$ wa -v
Wa version v0.8.1
</code></pre>
<p>The first time you execute the <code>wa</code> command, a <code>wa.wat2wasm.exe</code> command will be generated in the same directory as the command.</p>
<p>The installation is now completed.</p>
<h3 id="122-install-from-source-code"><a class="header" href="#122-install-from-source-code">1.2.2 Install from source code</a></h3>
<p>Installing from source requires installing Go1.17+ version, then execute the following command to install the latest Wa-lang compiler:</p>
<pre><code>go install wa-lang.org/wa
</code></pre>
<p>It will be installed to the <code>$HOME/go/bin</code> directory by default, so this directory path needs to be added to the system's <code>PATH</code> environment.
Then reopen the command line environment and execute the <code>wa</code> command once, the same help information as above will be output.</p>
<p>The first time you execute the <code>wa -v</code> command to view version information, a <code>wa.wat2wasm.exe</code> command will be generated in the same directory as the command.</p>
<p>The installation work is now completed.</p>
<h3 id="123-homebrew-macos--linux"><a class="header" href="#123-homebrew-macos--linux">1.2.3 Homebrew (MacOS &amp; Linux)</a></h3>
<p>For macOS and Linux systems, it can also be installed through Homebrew:</p>
<pre><code>brew install wa-lang/tap/wa
</code></pre>
<h3 id="124-scoop-windows"><a class="header" href="#124-scoop-windows">1.2.4 Scoop (Windows)</a></h3>
<p>For Windows systems, it can also be installed through Scoop:</p>
<pre><code>scoop bucket add wa-lang https://github.com/wa-lang/scoop-bucket.git
scoop install wa-lang/wa
</code></pre>
<h3 id="125-local-playground"><a class="header" href="#125-local-playground">1.2.5 local Playground</a></h3>
<p>After the Wa-lang compiler is successfully installed, enter <code>wa play</code> on the command line to open the local playground. The program will open the browser page by default, or you can enter the <a href="http://localhost:2023/">http://localhost:2023/</a> address to access. The effect is as follows:</p>
<p><img src="1.InstallAndGetStart/./images/playground-local-01.png" alt="" /></p>
<p>Click the &quot;Execute&quot; button to see the output results.</p>
<div style="break-before: page; page-break-before: always;"></div><p><em>The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: <a href="https://github.com/wa-lang/man/tree/master/en">https://github.com/wa-lang/man/tree/master/en</a></em></p>
<h2 id="13-wa-command-line"><a class="header" href="#13-wa-command-line">1.3. wa command line</a></h2>
<p>This section introduces the main functions of the <code>wa</code> command.</p>
<h3 id="131-help-message"><a class="header" href="#131-help-message">1.3.1. Help message</a></h3>
<p>Enter the <code>wa</code> command or <code>wa -h</code> to view command line help information, as follows:</p>
<pre><code>$ wa
NAME:
   Wa - Wa is a tool for managing Wa source code.

USAGE:
   wa [global options] command [command options] [arguments...]

VERSION:
   v0.8.1-mvp

COMMANDS:
   play   start Wa playground
   init   init a sketch Wa module
   build  compile Wa source code
   run    compile and run Wa program
   fmt    format Wa source code file
   test   test Wa packages
   yacc   generates parsers for LALR(1) grammars
   logo   print Wa text format logo

GLOBAL OPTIONS:
   --debug, -d              set debug mode (default: false)
   --trace value, -t value  set trace mode (*|app|compiler|loader)
   --help, -h               show help (default: false)
   --version, -v            print the version (default: false)

COPYRIGHT:
   Copyright 2018 The Wa Authors. All rights reserved.

See &quot;https://wa-lang.org&quot; for more information.
</code></pre>
<p>It has the following subcommands:</p>
<ul>
<li>play：Start the local version of the playground；</li>
<li>init: initialize a Wa-lang project;</li>
<li>build: compile Wa-lang program;</li>
<li>run: compile and execute the Wa-lang program;</li>
<li>fmt: format the Wa-lang source code file;</li>
<li>test: execute the unit test of the Wa-lang project;</li>
<li>yacc: The W-lang version of yacc, used to generate parser code for LALR(1) grammar rules;</li>
<li>logo: Print the logo in Wa-lang and text version.</li>
</ul>
<p>The build command has been shown in Section 1.1.1, and the play command has been shown in Section 1.2.5. This section briefly introduces other subcommands.</p>
<h3 id="132-initialize-project"><a class="header" href="#132-initialize-project">1.3.2 Initialize project</a></h3>
<p>In Section 1.1.1 we have shown that <code>wa run hello.wa</code> executes a Wa-lang program in a separate file. But a single-file Wa-lang program has a huge limitation - it has only one file and cannot reference non-standard library code. For larger Wa-lang it is recommended to organize them in project mode.</p>
<p>Use the <code>wa init</code> command to initialize a Wa project. Take a look at the command line help first:</p>
<pre><code>$ wa init -h
NAME:
   wa init - init a sketch Wa module

USAGE:
   wa init [command options] [arguments...]

OPTIONS:
   --name value, -n value     set app name (default: &quot;hello&quot;)
   --pkgpath value, -p value  set pkgpath file (default: &quot;myapp&quot;)
   --update, -u               update example (default: false)
   --help, -h                 show help (default: false)
</code></pre>
<p>This command has two important parameters, <code>-name</code> and <code>-pkgpath</code>, which correspond to the name of the project and the corresponding package path respectively. Each parameter has a default value, and you can use <code>wa init</code> to generate a hello project.</p>
<pre><code>$ wa init
$ tree hello
hello
├── LICENSE
├── README.md
├── src
│   ├── main.wa
│   ├── mymath
│   │   └── math.wa
│   ├── mypkg
│   │   └── pkg.wa
│   └── zz_test.wa
├── vendor
│   └── 3rdparty
│       └── pkg
│           └── pkg.wa
└── wa.mod

7 directories, 8 files
</code></pre>
<p>The structure of the project will be introduced in Section 1.4.</p>
<h3 id="133-compile-and-execute"><a class="header" href="#133-compile-and-execute">1.3.3 Compile and execute</a></h3>
<p>Enter the hello directory in the command line environment and enter <code>wa build</code> to build the wasm module in the output directory:</p>
<pre><code>$ wa build
$ tree output/
output/
├── hello.wasm
└── hello.wat

1 directory, 2 files
</code></pre>
<p>The default output is the WASI specificated <code>output/hello.wat</code> and <code>output/hello.wasm</code> files. The exported wasm module can be executed with standard tools. You can also use the <code>wa</code> command to execute:</p>
<pre><code>$ wa run ./output/hello.wasm
你好，凹语言！
5050
...
</code></pre>
<p>If you execute the <code>wa run</code> command without entry, it means that the current Wa-lang project will be compiled and executed. <code>output/hello.wasm</code> will be built first and then executed.</p>
<h3 id="134-format-code"><a class="header" href="#134-format-code">1.3.4 Format code</a></h3>
<p>The <code>wa fmt</code> command is used to format code, and its command line help information is as follows:</p>
<pre><code>$ wa fmt -h
NAME:
   wa fmt - format Wa source code file

USAGE:
   wa fmt [command options] [&lt;file.wa&gt;|&lt;path&gt;|&lt;path&gt;/...]

OPTIONS:
   --help, -h  show help (default: false)
</code></pre>
<p>The command line argument is the path to be formatted:</p>
<ul>
<li><code>wa fmt file.wa</code> formats the specified .wa file</li>
<li><code>wa fmt path</code> formats all .wa files in the specified directory</li>
<li><code>wa fmt path/...</code> recursively formats the .wa file in the specified path, including subdirectories</li>
</ul>
<p>If no parameters are specified, all .wa files in the current directory will be formatted by default. If the current directory belongs to the Wa-lang project, the .wa files in all subdirectories will be formatted by default.</p>
<h3 id="135-unit-test"><a class="header" href="#135-unit-test">1.3.5 Unit test</a></h3>
<p>The project generated by default will have a <code>src/zz_test.wa</code> test file with the following content:</p>
<pre><code class="language-wa">func TestSum {
    assert(sum(100) == 5050, &quot;sum(100) failed&quot;)
}

func ExampleSum {
    println(sum(100))

    // Output:
    // 5050
}
</code></pre>
<p>The result of testing <code>sum(100)</code> in the <code>TestSum</code> test function via the built-in <code>assert</code> function is 5050. In the <code>ExampleSum</code> example test function, pass <code>//Output:</code> to test that the output meets the expected results.</p>
<p>Execute the test through the <code>wa test</code> command in the command line environment of the project directory:</p>
<pre><code>$ wa test
ok   myapp 104ms
</code></pre>
<h3 id="136-wa-lang-version-of-yacc"><a class="header" href="#136-wa-lang-version-of-yacc">1.3.6 Wa-lang version of yacc</a></h3>
<p>yacc is a program for generating syntax parsers, a tool for compiler enthusiasts. The yacc of the Wa-lang language is transplanted from goyacc. For detailed usage, please refer to the <a href="https://wa-lang.org/smalltalk/st0021.html">related articles</a> in the SmallTalk section of the wa-lang official website .</p>
<h3 id="137-print-logo"><a class="header" href="#137-print-logo">1.3.7 Print Logo</a></h3>
<p><code>wa logo</code> can output some logo patterns in text format, and readers can explore by themselves through the <code>wa logo -h</code> command.</p>
<div style="break-before: page; page-break-before: always;"></div><p><em>The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: <a href="https://github.com/wa-lang/man/tree/master/en">https://github.com/wa-lang/man/tree/master/en</a></em></p>
<h2 id="14-project-directory-structure"><a class="header" href="#14-project-directory-structure">1.4. Project directory structure</a></h2>
<p>The project directory structure is the basis for the work of the entire peripheral tools. For example, init generates projects based on this structure, and the package management tool manages dependencies in turn.</p>
<h3 id="141-project-directory-structure"><a class="header" href="#141-project-directory-structure">1.4.1 Project directory structure</a></h3>
<p>Wa-lang programs organize code in packages. A package can be a single file or a directory. The <code>waroot/examples/hello</code> case that comes with Wa-lang is a more complete project, and its directory structure is as follows:</p>
<pre><code>examples/hello/
├── LICENSE
├── README.md
├── src
│   ├── main.wa
│   └── mymath
│       └── math.wa
├── vendor
│   └── 3rdparty
│       └── pkg
│           └── pkg.wa
└── wa.mod
</code></pre>
<p>In addition to copyright files and description files, the most important thing is the <code>wa.mod</code> package project file, which defines the package path of the current application. In addition, the code in the src directory is the code under the current package path, which is the default main entry package.</p>
<p>The contents of the <code>wa.mod</code> file are as follows:</p>
<pre><code class="language-ini">name = &quot;hello&quot;
pkgpath = &quot;myapp&quot;
version = &quot;0.0.1&quot;
</code></pre>
<p>Among them, pkgpath represents the path of the current package, so it can be deduced that the package path corresponding to the mymath subdirectory is <code>&quot;myapp/mymath&quot;</code>. The vendor directory is the dependent third-party code, where the package path corresponding to <code>vendor/3rdparty/pkg</code> is <code>&quot;3rdparty/pkg&quot;</code>.</p>
<h3 id="142-package-management-tool"><a class="header" href="#142-package-management-tool">1.4.2 Package management tool</a></h3>
<p>Wa-lang currently does not have a package management tool. If you rely on third-party packages, you need to manually synchronize the vendor directory. The development team hopes to start developing package management tool after the MVP version.</p>
<div style="break-before: page; page-break-before: always;"></div><p><em>The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: <a href="https://github.com/wa-lang/man/tree/master/en">https://github.com/wa-lang/man/tree/master/en</a></em></p>
<h2 id="15-plug-ins-for-ide"><a class="header" href="#15-plug-ins-for-ide">1.5. Plug-ins for IDE</a></h2>
<p>Modern programming languages generally provide extensions for various IDEs and editors to improve the programming experience. The Wa-lang provides basic plug-in support for VS Code, Fleet and Vim.</p>
<h3 id="151-plug-in-for-vscode"><a class="header" href="#151-plug-in-for-vscode">1.5.1 Plug-in for VSCode</a></h3>
<p>Search for &quot;wa&quot; in the VS Code extension store to find the Wa-lang plugin. After installation, there will be basic syntax highlighting and other functions.</p>
<p>The effect of it is as follows:</p>
<p><img src="1.InstallAndGetStart/./images/vscode.png" alt="" /></p>
<h3 id="152-plug-in-for-fleet"><a class="header" href="#152-plug-in-for-fleet">1.5.2 Plug-in for Fleet</a></h3>
<p>Repository: <a href="https://github.com/wa-lang/fleet-wa">https://github.com/wa-lang/fleet-wa</a></p>
<p>Install according to the warehouse prompts, the effect is as follows:</p>
<p><img src="1.InstallAndGetStart/./images/fleet-wa-screenshot.png" alt="" /></p>
<h3 id="153-plug-in-for-vim"><a class="header" href="#153-plug-in-for-vim">1.5.3 Plug-in for Vim</a></h3>
<p>Vim plug-in repository: <a href="https://github.com/wa-lang/vim-wa">https://github.com/wa-lang/vim-wa</a></p>
<p>Install according to the warehouse prompts, the effect is as follows:</p>
<p><img src="1.InstallAndGetStart/./images/vim-wa-screenshot.png" alt="" /></p>
<h3 id="154-other-plug-ins"><a class="header" href="#154-other-plug-ins">1.5.4 Other Plug-ins</a></h3>
<p>After the MVP, the syntax of the Wa-lang has been stablized, and we hope that the community can participate in the co-construction of other editors to support it.</p>
<div style="break-before: page; page-break-before: always;"></div><p><em>The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: <a href="https://github.com/wa-lang/man/tree/master/en">https://github.com/wa-lang/man/tree/master/en</a></em></p>
<h1 id="2-program-structure"><a class="header" href="#2-program-structure">2. Program structure</a></h1>
<p>Like other programming languages, a Wa-lang program is composed of many small parts. This chapter introduces global variable declarations, function declarations, constant declarations, import declarations, and type declarations.</p>
<div style="break-before: page; page-break-before: always;"></div><p><em>The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: <a href="https://github.com/wa-lang/man/tree/master/en">https://github.com/wa-lang/man/tree/master/en</a></em></p>
<h2 id="21-global-declaration"><a class="header" href="#21-global-declaration">2.1. Global declaration</a></h2>
<p>A typical Wa-lang program source code is as follows:</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

import &quot;errors&quot;

const PI = 3.1415926

global 终极问题的答案: i32

func main {
    终极问题的答案 = getAnswer()
    println(&quot;宇宙的答案：&quot;, 终极问题的答案)
    println(&quot;π:&quot;, PI)

    err := errors.New(&quot;!!!&quot;)
    println(&quot;err:&quot;, err.Error())
}

func getAnswer =&gt; i32 {
    return 42
}
</code></pre>
<blockquote>
<p>Similar to many languages, in Wa-lang, the part from the double slash <code>//</code> to the end of the line is a comment and has no actual effect.</p>
</blockquote>
<p>Wa code consists of <code>global declarations</code>, like in the example above:</p>
<ul>
<li><code>import &quot;errors&quot;</code> is a declaration that imports the <code>errors</code> module</li>
<li><code>const PI = 3.1415926</code> is a constant declaration, which declares a constant named <code>PI</code> with the value 3.1415926</li>
<li><code>global The answer to the ultimate question: i32</code> is a global variable declaration, which declares a global variable named <code>The answer to the ultimate question</code>, of type 32-bit integer</li>
<li><code>func getAnswer =&gt; i32 {...}</code> is a function declaration that declares a function that returns a 32-bit integer</li>
</ul>
<p>There are 5 global declarations in Wa-lang. Each declaration starts with a specific keyword (followed by the entity of the declaration object). The relationship between the declaration and the corresponding keywords is as follows:</p>
<ul>
<li><code>global</code>: global variable declaration</li>
<li><code>func</code>: function declaration</li>
<li><code>const</code>: constant declaration</li>
<li><code>import</code>: import declaration</li>
<li><code>type</code>: type declaration</li>
</ul>
<p>The following sections of this chapter will introduce global variable declarations, function declarations, constant declarations, and import declarations in sequence. Type declarations will be explained separately in Chapter 6.</p>
<div style="break-before: page; page-break-before: always;"></div><p><em>The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: <a href="https://github.com/wa-lang/man/tree/master/en">https://github.com/wa-lang/man/tree/master/en</a></em></p>
<h2 id="22-global-variable-declaration"><a class="header" href="#22-global-variable-declaration">2.2. Global variable declaration</a></h2>
<p>Global variable declaration starts with the keyword <code>global</code>, and the general syntax is as follows:</p>
<pre><code class="language-wa">global VarName: Type = initial value expression
</code></pre>
<p>For example:</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

global aInt: i32 = 42     // 32-bit signed integer
global _num: f32 = 952.7  // 32-bit floating point number

func main {
    println(aInt)
    println(_num)
    println(名字)
    println(counter)
}

global 名字: string = &quot;张三&quot; // string
global counter: u32         // 32-bit unsigned integer
</code></pre>
<p>The output of this program is as follows:</p>
<pre><code>42
952.7
张三
0
</code></pre>
<p>Global variables can be used anywhere inside the module - even if the declaration and use of global variables are in different source files, as long as they are in the same module; in the source file, there is no need to &quot;declare first and then use&quot;. In the above example, the variables <code>name</code> and <code>counter</code> can reflect this feature.</p>
<p>It should be noted that the variable <code>counter</code> in the above example is declared without an initial value:</p>
<blockquote>
<p>In Wa-lang, variables that are not given an initial value are always initialized with a value of 0, which helps eliminate uncertainty.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p><em>The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: <a href="https://github.com/wa-lang/man/tree/master/en">https://github.com/wa-lang/man/tree/master/en</a></em></p>
<h2 id="23-function-declaration"><a class="header" href="#23-function-declaration">2.3. Function declaration</a></h2>
<p>The function declaration starts with the keyword <code>func</code>, and the general syntax is as follows:</p>
<pre><code class="language-wa">func FunctionName (parameter list) =&gt; (return value list) {function body}
</code></pre>
<p>For example：</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

func swap(i, j: i32) =&gt; (i32, i32) {
    return j, i
}

func main {
    a, b := swap(4, 2)
    println(&quot;a:&quot;, a, &quot;, b:&quot;, b)
    println(add(a, b))
}

func add(i, j: i32) =&gt; i32 {
    return i + j
}
</code></pre>
<p>The output of this program is as follows:</p>
<pre><code>a: 2 , b: 4
6
</code></pre>
<p>For functions without return values, the <code>=&gt; (return value list)</code> part can be omitted, and for functions without input parameters, the <code>(parameter list)</code> part can be omitted, such as in the above example: <code>func main {... }</code>, which is the abbreviation of: <code>func main() =&gt; () {...}</code>.</p>
<p>Like global variables, functions can be declared in any source file within a package and do not require &quot;declare before use&quot;.</p>
<p>See Chapter 4 for more information about functions.</p>
<div style="break-before: page; page-break-before: always;"></div><p><em>The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: <a href="https://github.com/wa-lang/man/tree/master/en">https://github.com/wa-lang/man/tree/master/en</a></em></p>
<h2 id="24-constant-declaration"><a class="header" href="#24-constant-declaration">2.4. Constant declaration</a></h2>
<p>The constant declaration starts with the keyword <code>const</code>, and the general syntax is as follows:</p>
<pre><code class="language-wa">const 常量名: 类型 = 常量值
</code></pre>
<p>For example:</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

const Answer: i32 = 42
const aConstString: string = &quot;你好，凹语言&quot;

func main {
    println(Answer)
    println(aConstString)
    println(aConstInt)
}

const aConstInt = 13
</code></pre>
<p>The output of this program is as follows:</p>
<pre><code>42
你好，凹语言
13
</code></pre>
<p>When declaring a constant, if you do not specify a type (such as <code>aConstInt</code> in the above example), then it will be an <strong>untyped constant</strong>. There are 4 types of untyped constants: <code>untyped integer</code>, <code>untyped floating point number</code>, <code>untyped characters</code>, <code>untyped strings</code>, respectively:</p>
<pre><code class="language-wa">const aUntypedInt = 11       // untyped integer
const aUntypedFloat = 13.0   // untyped floating point number
const aUntypedRune = 'a'     // untyped characters
const aUntypedString = &quot;abc&quot; // untyped strings
</code></pre>
<p>Arithmetic and logical operations on constant values are completed at compile time, such as:</p>
<pre><code class="language-wa">// 版权 @2019 凹语言 作者。保留所有权利。

const K = 4200000000000000000000000
const J = 4200000000000000000000000

func main {
    println(K/J)
}
</code></pre>
<p>Although the values of <code>K</code> and <code>J</code> both exceed the expression range of <code>i64</code>(the largest type in Wa-lang), the value of <code>K/J</code> can still be printed correctly. This also reflects that <strong>numeric constants have an expression range and precision that exceeds the basic type of variables</strong>.</p>
<p>The relevant rules when assigning constants to variables will be discussed in detail in Chapter 3.</p>
<div style="break-before: page; page-break-before: always;"></div><p><em>The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: <a href="https://github.com/wa-lang/man/tree/master/en">https://github.com/wa-lang/man/tree/master/en</a></em></p>
<h2 id="25-import-declaration"><a class="header" href="#25-import-declaration">2.5. Import declaration</a></h2>
<p>The import declaration starts with the keyword <code>import</code>, and the general syntax is as follows:</p>
<pre><code class="language-wa">import path
</code></pre>
<p>For example：</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

import &quot;errors&quot;

func main {
    err := errors.New(&quot;!!!&quot;)
    println(&quot;err:&quot;, err.Error())
}

func getAnswer =&gt; i32 {
    return 42
}
</code></pre>
<p>The <code>import &quot;errors&quot;</code> declaration at the beginning of the program imports the built-in <code>errors</code> module, and the public objects of this module can be used in subsequent functions - such as the <code>errors.New</code> function in the example; <code>.</code> in It is called the <strong>selection operator</strong> here. Its meaning is to select the object (module) on the left with the same name as the one on the right. In addition to selecting functions and global functions exposed by the module, Objects such as variables are also used to select members of structures (see Chapter 6 for details).</p>
<p>Import declarations should precede all non-import declarations within the source file (i.e., in the header, immediately after the file header comment). If you import multiple modules, you can use brackets to import them in groups, like this:</p>
<pre><code class="language-wa">import (
    &quot;errors&quot;
    &quot;strconv&quot;
)
</code></pre>
<p>This is equivalent to the following:</p>
<pre><code class="language-wa">import &quot;errors&quot;
import &quot;strconv&quot;
</code></pre>
<p>When importing a module, you can give the module an alias. The general syntax is as follows:</p>
<pre><code class="language-wa">import path =&gt; alias
</code></pre>
<p>This can solve the problem of name conflict when importing two modules with different paths but the same name at the same time, for example:</p>
<pre><code class="language-wa">import (
    &quot;errors&quot;
    &quot;mypackage/errors&quot; =&gt; myerrors
)

func main {
    err := errors.New(&quot;!!!&quot;)     // Call the built-in errors module
    myerr := myerrors.New(&quot;!!!&quot;) // Call the mypackage/errors module块
}
</code></pre>
<blockquote>
<p>Unlike other declarations, the scope of the <strong>import declaration is the current source file</strong>. If two source files in a module use the same third-party module, then their import declarations are required in both files.</p>
</blockquote>
<p>In Wa-lang, every module imported by a source file must be used, that is, if a module is imported but none of its objects are used, it will be considered a syntax error.</p>
<div style="break-before: page; page-break-before: always;"></div><p><em>The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: <a href="https://github.com/wa-lang/man/tree/master/en">https://github.com/wa-lang/man/tree/master/en</a></em></p>
<h1 id="3-basic-types"><a class="header" href="#3-basic-types">3. Basic types</a></h1>
<p>At a low level, all data is made up of bits. The corresponding basic data types of Wa-lang include integers, floating point numbers, strings, etc. This chapter introduces basic data types and the use of local variables.</p>
<div style="break-before: page; page-break-before: always;"></div><p><em>The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: <a href="https://github.com/wa-lang/man/tree/master/en">https://github.com/wa-lang/man/tree/master/en</a></em></p>
<h2 id="31-local-variable-declaration"><a class="header" href="#31-local-variable-declaration">3.1. Local variable declaration</a></h2>
<p>Chapter 2 introduces global variable and constant declarations. Also commonly used is local variable (variables defined within a function) declaration. Its general syntax is:</p>
<pre><code class="language-wa">VarName: Type = initial Value
</code></pre>
<p>What is different from all variables and constants is that the declaration of local variables does not start with a keyword; when declaring a local variable, if the <code>= initial value</code> part is omitted, the variable will be initialized with a value of 0, such as:</p>
<pre><code class="language-wa">    aI32: i32 = 42
    aString: string = &quot;你好&quot;
    aF32: f32  // 0.0
</code></pre>
<p>Another commonly used syntax for declaring local variables uses the short-declaration <code>:=</code>. The syntax is as follows:</p>
<pre><code class="language-wa">VarName := expression
</code></pre>
<p>When using this writing method, the type of the variable will be consistent with the type of the expression on the right side of the short-declaration, and the value of the expression will be assigned to the initial value of the local variable, such as:</p>
<pre><code class="language-wa">    a := 13          // int
    f := 3.14        // f64
    s := genString() // string
...
func genString() =&gt; string { return &quot;Hello&quot; }
</code></pre>
<blockquote>
<p>Wa-lang is a statically typed language. The type of a legal expressions can be inferred at compile time, so the type of a expression is determined. The <code>:=</code> syntax is similar to C++'s <code>auto</code> type.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p><em>The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: <a href="https://github.com/wa-lang/man/tree/master/en">https://github.com/wa-lang/man/tree/master/en</a></em></p>
<h2 id="32-integers"><a class="header" href="#32-integers">3.2. Integers</a></h2>
<p>Wa-lang currently supports the following integer types:</p>
<ul>
<li><code>u8</code>: unsigned 8-bit integer;</li>
<li><code>u16</code>: unsigned 16-bit integer;</li>
<li><code>i32</code>: signed 32-bit integer;</li>
<li><code>u32</code>: unsigned 32-bit integer;</li>
<li><code>i64</code>: signed 64-bit integer;</li>
<li><code>u64</code>: unsigned 64-bit integer;</li>
<li><code>int</code>: signed integer;</li>
<li><code>uint</code>: unsigned integer;</li>
<li><code>bool</code>: Boolean type.</li>
</ul>
<p>Among them:</p>
<ul>
<li><code>int</code> and <code>uint</code> are variable-width integers, and their width is determined by the target platform. The reason why there are variable-width integer types is that the addressing range of the target platform may be different. Operations involving the storage range such as the built-in function <code>len</code> require a unified data type to ensure that the code can be compiled normally on different target platforms. And make full use of the platform addressing range;</li>
<li>The actual memory layout of <code>bool</code> type is <code>u8</code>, the literal values of legal values are <code>true</code>, <code>false</code>, and the corresponding memory values ​​are 1 and 0.</li>
</ul>
<blockquote>
<p>The current main target platform of Wa-lang is <strong>wasm32</strong>. Under this platform, the bit width of variable-width integers is 32 bits, which is 4 bytes.</p>
</blockquote>
<p>Integers other than Boolean support the following unary operations:</p>
<ul>
<li><code>^</code>: bitwise negation</li>
<li><code>-</code>: Take the negative arithmetic value (that is, subtract the operand from 0)</li>
</ul>
<p>For example：</p>
<pre><code class="language-wa">    i: u8 = 9
    println(^i) // 246
    println(-i) // 247

    j: i32 = 9
    println(^i) // -10
    println(-i) // -9
</code></pre>
<p>Integers other than Boolean support the following binary arithmetic operations:</p>
<ul>
<li><code>+</code>: Add, the two operand types must be consistent, the type of return value is same with operands;</li>
<li><code>-</code>: Minus, the two operand types must be consistent, the type of return value is same with operands;</li>
<li><code>*</code>: Mul, the two operand types must be consistent, the type of return value is same with operands;</li>
<li><code>/</code>: Div, the two operand types must be consistent, the type of return value is same with operands;</li>
<li><code>%</code>: Rem, the two operand types must be consistent, the type of return value is same with operands;</li>
</ul>
<p>For example：</p>
<pre><code class="language-wa">    i, j: u8 = 9, 250
    println(i + j) // 3
    println(i - j) // 15
    println(i * j) // 202
    println(j / i) // 27
    println(j % i) // 7
</code></pre>
<p>Integers(except Boolean) support the following binary bit operations:</p>
<ul>
<li><code>&amp;</code>: bitwise AND, the two operand types must be consistent, the type of return value is same with operands;</li>
<li><code>|</code>: Bitwise OR, the two operand types must be consistent, the type of return value is same with operands;</li>
<li><code>^</code>: Bitwise XOR, the two operand types must be consistent, the type of return value is same with operands;</li>
<li><code>&amp;^</code>: clear bitwise, the two operand types must be consistent, the type of return value is same with operands. For <code>z = x ^&amp; y</code>, let <code>xn</code>, <code>yn</code>, <code>zn</code> be the nth bit of <code>x</code>, <code>y</code>, <code>z</code> respectively, then when <code>yn</code> is 1, <code>zn </code> is 0, otherwise <code>zn</code> is equal to <code>xn</code>. This operation is equivalent to <code>z = x &amp; (^y)</code>;</li>
<li><code>&lt;&lt;</code>: Left shift, for <code>z = x &lt;&lt; y</code>, the type of <code>z</code> is consistent with <code>x</code>, <code>y</code> must be an integer greater than 0, and the low-order bit is filled with 0 when shifting;</li>
<li><code>&gt;&gt;</code>: Right shift, for <code>z = x &gt;&gt; y</code>, the type of <code>z</code> is consistent with <code>x</code>, <code>y</code> must be an integer greater than 0, and the high bit is filled with 0 when shifting.</li>
</ul>
<p>For example：</p>
<pre><code class="language-wa">    i, j: u16 = 343, 47831
    println(i &amp; j)  // 87
    println(i | j)  // 48087
    println(i ^ j)  // 48000
    println(i &amp;^ j) // 256
    println(i &lt;&lt; 5) // 10976
    println(j &gt;&gt; 5) // 1494
</code></pre>
<p>The results of operations such as addition, subtraction, multiplication, and left shift may exceed the expression range of the operands. In this case, the low-order part will be intercepted as the result.</p>
<p>Integers except Boolean support the following comparison operations:</p>
<ul>
<li><code>==</code>: equal. The operands types must be consistent, and the return value is of <code>bool</code> type. If the judgment condition is met, <code>true</code> will be returned, otherwise <code>false</code> will be returned, the same below;</li>
<li><code>!=</code>: not equal;</li>
<li><code>&gt;</code>: greater than;</li>
<li><code>&gt;=</code>: greater than;</li>
<li><code>&lt;</code>: less than;</li>
<li><code>&lt;=</code>: Small equal to.</li>
</ul>
<blockquote>
<p>If one of the two operands involved in the comparison is a constant, the constant should be on the right side of the comparison operator.</p>
</blockquote>
<p>Boolean types support the following unary operations:</p>
<ul>
<li><code>!</code>: negation, if the operand is <code>false</code>, return <code>true</code>, otherwise return <code>false</code>.</li>
</ul>
<p>In fact, in addition to the named constants declared through constants introduced in Section 2.4, many literal values appearing in the code are also constants, such as:</p>
<pre><code class="language-wa">     i := 13
</code></pre>
<p><code>13</code> in the code is an untyped integer constant. When using untyped integer constants for variable short-declaration, the type of the variable is a variable-width signed integer (that is, <code>int</code>). The above code is equivalent to:</p>
<pre><code class="language-wa">     i: int
     i=13
</code></pre>
<p>When assigning an integer constant to an integer variable, type and range checking will be performed at compile time and automatically matched to the variable type - assigning a negative constant to an unsigned integer, or a constant value that exceeds the width of the assigned variable will be judged as illegal.</p>
<p>Integers support all binary operators, and binary operators have decreasing precedence in the following order (same precedence within the same line, executed from left to right):</p>
<pre><code>*      /      %      &lt;&lt;       &gt;&gt;     &amp;       &amp;^
+      -      |      ^
==     !=     &lt;      &lt;=       &gt;      &gt;=
&amp;&amp;
||
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><em>The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: <a href="https://github.com/wa-lang/man/tree/master/en">https://github.com/wa-lang/man/tree/master/en</a></em></p>
<h2 id="33-floating-point-number"><a class="header" href="#33-floating-point-number">3.3. Floating point number</a></h2>
<p>Wa-lang currently supports the following types of floating point numbers (both are IEEE 754 standards):</p>
<ul>
<li><code>f32</code>: 32-bit floating point number</li>
<li><code>f64</code>: 64-bit floating point number</li>
</ul>
<p>Floating point numbers support the following unary operators</p>
<ul>
<li><code>-</code>: Get the negative arithmetic value (that is, subtract the operand from 0)</li>
</ul>
<p>For example：</p>
<pre><code class="language-wa">    i: f32 = 1.25
    println(-i) //-1.25
</code></pre>
<p>Floating point numbers support the following binary arithmetic operations:</p>
<ul>
<li><code>+</code>: Add, the two operand types must be consistent, the type of return value is same with operands;</li>
<li><code>-</code>: Minus, the two operand types must be consistent, the type of return value is same with operands;</li>
<li><code>*</code>: Mul, the two operand types must be consistent, the type of return value is same with operands;</li>
<li><code>/</code>: Div, the two operand types must be consistent, the type of return value is same with operands;</li>
</ul>
<p>For example：</p>
<pre><code class="language-wa">    i, j: f64 = 1, 0.5
    println(i + j) // 1.5
    println(i - j) // 0.5
    println(i * j) // 0.5
    println(j / i) // 2
</code></pre>
<p>Floating point numbers support the following comparison operations:</p>
<ul>
<li><code>==</code>: equal. The operands types must be consistent, and the return value is of <code>bool</code> type. If the judgment condition is met, <code>true</code> will be returned, otherwise <code>false</code> will be returned, the same below;</li>
<li><code>!=</code>: not equal;</li>
<li><code>&gt;</code>: greater than;</li>
<li><code>&gt;=</code>: greater than;</li>
<li><code>&lt;</code>: less than;</li>
<li><code>&lt;=</code>: Small equal to.</li>
</ul>
<p>When using untyped floating-point constants for variable short-declaration, the variable type is <code>f64</code>. The following two ways of writing are equivalent:</p>
<pre><code class="language-wa">    f := 1.5
</code></pre>
<pre><code class="language-wa">    f: f64 = 1.5
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><em>The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: <a href="https://github.com/wa-lang/man/tree/master/en">https://github.com/wa-lang/man/tree/master/en</a></em></p>
<h2 id="34-string"><a class="header" href="#34-string">3.4. String</a></h2>
<p>Strings are regarded as basic data types in Wa-lang. The type name is: <code>string</code>. String literal constants are defined by double quotes <code>&quot;&quot;</code> and are encoded in UTF-8, for example:</p>
<pre><code class="language-wa">    s: string = &quot;你好，凹语言&quot;
    println(s)     // 你好，凹语言
    println(&quot;+42&quot;) // +42
</code></pre>
<p>Similar to integers and floating point numbers, string variables can also be defined using short-declaration <code>:=</code>, for example:</p>
<pre><code class="language-wa">    s := &quot;编号9527&quot;
</code></pre>
<p>Strings support add (<code>+</code>) binary operations, and the return value is the concatenation of two strings, for example:</p>
<pre><code class="language-wa">    s1 := &quot;abc&quot;
    s2 := &quot;123&quot;
    println(s1 + s2) // abc123
</code></pre>
<p>The underlying structure that holds a string is a byte (that is, <code>u8</code>) array. You can use <code>[]</code> to get the value of a certain byte, or a substring, for example:</p>
<pre><code class="language-wa">    s := &quot;abcdefg&quot;
    println(s[2])   // 99，the ASCII value of 'c'
    println(s[1:3]) // bc
</code></pre>
<p>In this usage, the subscripted units within <code>[]</code> are bytes, not characters. If the source string contains non-ASCII characters (such as Chinese characters) and the subscript is not at an right boundary, the returned substring may be illegal, for example:</p>
<pre><code class="language-wa">    s := &quot;你好&quot;
    println(s[1:3]) // ��
</code></pre>
<p><code>s[m:n]</code> operation starts from the <code>n</code>th byte, and the length of the returned string is <code>n-m</code> bytes. If <code>m</code> is omitted, it means start from the beginning of the string. If <code>n</code> is omitted, it means intercepting to the end of the string. For example:</p>
<pre><code class="language-wa">    s := &quot;abcdefg&quot;
    println(s[:3]) // abc
    println(s[3:]) // defg
</code></pre>
<p>From the perspective of the underlying data, when intercepting the substring, there is no re-alloc for a byte array copy, but a direct reference to the address of the original string. In order to avoid the impact of mutual modification of multiple strings referencing the same memory, the string is set so that it cannot be modified locally - neither can it be assigned to <code>s[n]</code>. The following example are illegal:</p>
<pre><code class="language-wa">    s := &quot;abcdefg&quot;
    s[0] = 99 // illegal
</code></pre>
<p>You can use the <code>==</code> and <code>!=</code> operators to determine equality or inequality between two strings, for example:</p>
<pre><code class="language-wa">    s := &quot;abc&quot;
    println(s == &quot;123&quot;) // false
    println(s != &quot;123&quot;) // true
</code></pre>
<p>The built-in function <code>len</code> can be used to get the length of a string in bytes, such as:</p>
<pre><code class="language-wa">    s := &quot;abcdefg&quot;
    println(len(s)) // 7
</code></pre>
<hr />
<p>List of known issues:</p>
<ul>
<li>Bounds checking was not performed when using <code>[]</code> to obtain the specified bytes or substring of a string variable. This problem does not affect syntax compatibility. Subsequent corrections to this problem will not affect the existing source code. Developers using Wa-lang do not need to deal with this issue specially.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p><em>The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: <a href="https://github.com/wa-lang/man/tree/master/en">https://github.com/wa-lang/man/tree/master/en</a></em></p>
<h1 id="4-function"><a class="header" href="#4-function">4. Function</a></h1>
<p>Functions are sequences of statements designed to be reused many times. This chapter introduces the basic usage of Wa-lang functions, as well as features such as function values, anonymous functions, and closures.</p>
<div style="break-before: page; page-break-before: always;"></div><p><em>The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: <a href="https://github.com/wa-lang/man/tree/master/en">https://github.com/wa-lang/man/tree/master/en</a></em></p>
<h2 id="41-function-call"><a class="header" href="#41-function-call">4.1. Function call</a></h2>
<p>We have come across many functions in previous chapters, such as the commonly used built-in printing function <code>println</code>. The general syntax for function calls is:</p>
<p><code>FunctionName (actual parameter list)</code></p>
<p><code>Actual parameters</code> refer to the parameters actually passed in when the function is called, corresponding to the <code>formal parameters</code> defined when the function is declared. The formal parameters are only valid within the function body. When calling a function in Wa-lang, parameters are passed by value. Changes to the formal parameter values within the function body will not affect the actual parameter values, for example:</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

func Double(i: i32) =&gt; i32 {
    i = i * 2
    return i
}

func main {
    j: i32 = 42
    println(Double(j)) // 84
    println(j)         // 42
}
</code></pre>
<p>The keyword <code>return</code> is used to exit the function and return values. The general syntax is:</p>
<pre><code class="language-wa">return ValueList
</code></pre>
<p>If a function has multiple return values, they should be separated by <code>,</code>, for example:</p>
<pre><code class="language-wa">func MulRet() =&gt; (i32, i32) {
    return 42, 13
}
</code></pre>
<p>Similar to formal parameters, named return values can be defined when a function is declared, for example:</p>
<pre><code class="language-wa">func showAnswer() =&gt; (answer: i32) {
    answer = 42
    return
}
</code></pre>
<p>This is equivalent to:</p>
<pre><code class="language-wa">func showAnswer() =&gt; i32 {
    answer: i32
    answer = 42
    return answer
}
</code></pre>
<p>Like other variables, named return values are initialized with a value of 0. If a function witch has many branches needs to return an error code, and most branch error codes have a value of 0, using a named return value can simplify the code.</p>
<p>Even if a named return value is declared, <code>return</code> can still return other values, such as:</p>
<pre><code class="language-wa">// 版权 @2019 凹语言 作者。保留所有权利。

func showAnswer() =&gt; (answer: i32) {
    answer = 13
    return 42
}

func main {
    println(showAnswer()) // 42
}
</code></pre>
<p>So we can understand it this way: the named return value actually defines a set of local variables in the function body. When the <code>return</code> statement within the function does not specify a return value, this set of local variables is automatically filled in as the return value.</p>
<div style="break-before: page; page-break-before: always;"></div><p><em>The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: <a href="https://github.com/wa-lang/man/tree/master/en">https://github.com/wa-lang/man/tree/master/en</a></em></p>
<h2 id="42-function-values"><a class="header" href="#42-function-values">4.2. Function values</a></h2>
<p>In Wa-lang, functions can be treated as special values, for example:</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

func Inc(i: i32) =&gt; i32 { return i + 1 }
func Dec(i: i32) =&gt; i32 { return i - 1 }

func main {
    f := Inc
    println(f(42)) // 43

    f = Dec
    println(f(42)) // 41
}
</code></pre>
<p>In the above example, <code>f</code> is the <strong>function value</strong>. The function value can be called, and the calling method is the same as the function call.</p>
<p>The type of a function is determined by its parameters and return value type. Usually this information is called <strong>function signature</strong> (Signature). If two functions A and B have the same signature, it means that they:</p>
<ul>
<li>Their number of parameters is the same;</li>
<li>Their number of return values is the same;</li>
<li>For any n, the nth parameter of function A is of the same type as the nth parameter of B;</li>
<li>For any m, the mth return value of function A is of the same type as the mth return value of B.</li>
</ul>
<p>The type of function value is also defined through function signature. For example, the type of function value <code>f</code> in the above example is <code>func(i32) =&gt; i32</code>, so the short-declaration of <code>f</code> in the above example is <code>f := Inc</code>, etc. Priced at:</p>
<pre><code class="language-wa">    f: func(i32) =&gt; i32 // f == nil
    f = Inc
</code></pre>
<blockquote>
<p>Like other types of values, function values are also initialized to 0, and the corresponding value is <code>nil</code></p>
</blockquote>
<p>In Wa-lang, values of different types cannot be assigned to each other. This is also valid for function values. Since the function type is determined by the signature, it is considered illegal to assign a function to a function value with different signatures. For example:</p>
<pre><code class="language-wa">func Inc(i: i32) =&gt; i32 { return i + 1 }

func main {
    f: func(i32)
    f = Inc // 编译错误
}
</code></pre>
<p>Since it is called a &quot;value&quot;, it means that function values can be passed between different functions as parameters and return values, for example:</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

func inc(i: i32) =&gt; i32 { return i + 1 }
func dec(i: i32) =&gt; i32 { return i - 1 }
func getFunc(opCode: i32) =&gt; func(i32) =&gt; i32 {
    if opCode == 0 {
        return inc
    } else if opCode == 1 {
        return dec
    } else {
        return nil
    }
}

func useFunc(i: i32, f: func(i32) =&gt; i32) {
    if f == nil {
        println(&quot;f == nil&quot;)
        return
    }
    println(f(i))
}

func main {
    useFunc(42, getFunc(0)) // 43
    useFunc(42, getFunc(1)) // 41
    useFunc(42, getFunc(2)) // f == nil
    getFunc(2)(42)          // 运行时异常
}
</code></pre>
<p>Unlike other basic types, function values can only be compared with <code>nil</code>, that is: when the function value is on the left side of operators <code>==</code>, <code>!=</code>, the right side can only be <code>nil</code>, comparing two non-constants function value is considered illegal.</p>
<p>If the called function value is <code>nil</code>, an unrecoverable runtime exception will be triggered.</p>
<p>Function values are similar to function pointers in C language, and can dynamically adjust execution branches more flexibly. However, it needs to be pointed out that compared to calling the function directly, calling the function value has some additional consumption, and performance-sensitive occasions require special attention.</p>
<div style="break-before: page; page-break-before: always;"></div><p><em>The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: <a href="https://github.com/wa-lang/man/tree/master/en">https://github.com/wa-lang/man/tree/master/en</a></em></p>
<h2 id="43-anonymous-functions-and-closures"><a class="header" href="#43-anonymous-functions-and-closures">4.3. Anonymous functions and closures</a></h2>
<p>The previous section introduced the basic usage of function values. Since functions can be regarded as values, can function literals be declared inside functions in the same way as basic type literals? The answer is yes, for example:</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

func useFunc(i: i32, f: func(i32) =&gt; i32) {
    if f == nil {
        println(&quot;f == nil&quot;)
        return
    }
    println(f(i))
}

func main {
    f := func(i: i32) =&gt; i32 { return i * i } // Declare an anonymous function and assign it to f
    useFunc(3, f) // 9
}
</code></pre>
<p>Among them, <code>f</code> is a function value, its initial value is the literal <code>func(i: i32) =&gt; i32 { return i * i }</code>, which is a function without a name. In Wa-lang, this kind of function literal without a name is called an anonymous function. In application scenarios such as visitor mode and custom quick sorting, it is often necessary to pass in some function value parameters, and these functions may only appear once. For this reason, it is inconvenient to define additional module-level global functions. You can use anonymous functions.</p>
<p><strong>Anonymous function B declared inside function A can access local variables inside A</strong>, for example:</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

func useFunc(i: i32, f: func(i32) =&gt; i32) {
    if f == nil {
        println(&quot;f == nil&quot;)
        return
    }
    println(f(i))
}

func main {
    n: i32 = 0
    f := func(i: i32) =&gt; i32 {
        n = i * i
        return n
    }
    useFunc(3, f)
    println(n) // 9
}
</code></pre>
<p>Obviously the function value <code>f</code> can read and write the outer local variable <code>n</code>. Let’s look at a more complex example:</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。
func genClosure(i: i32) =&gt; func() =&gt; i32 {
    n := i
    return func() =&gt; i32 {
        n = n + 1
        return n
    }
}

func main {
    c := genClosure(0)
    d := genClosure(99)

    println(c()) // 1
    println(d()) // 100
    println(c()) // 2
    println(d()) // 101
}
</code></pre>
<p>Each call to <code>genFunc</code> will generate a function value. This function value captures the local variable <code>n</code>. Each time the function value is executed, the captured <code>n</code> will be incremented by 1. The function obtained by executing <code>genFunc</code> multiple times value, the <code>n</code> they capture is different, and each time it is executed, a new instance is captured.</p>
<p>The anonymous function value declared within the function carries the state of the local variables captured during this run. Obviously, this function value is essentially a closure.</p>
<div style="break-before: page; page-break-before: always;"></div><p><em>The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: <a href="https://github.com/wa-lang/man/tree/master/en">https://github.com/wa-lang/man/tree/master/en</a></em></p>
<h2 id="44-if-statements"><a class="header" href="#44-if-statements">4.4. if statements</a></h2>
<p>The general form of conditional statements is:</p>
<pre><code class="language-wa">     if initial statement, conditional expression {
         code block 1
     } else {
         Code block 2
     }
</code></pre>
<p>Among them, <code>conditional expression</code> must be of Boolean type. The conditional statement first executes the optional <code>initial statement</code> (<code>initial statement,</code> can be omitted, which means there is no initial action), and then determines whether <code>conditional expression</code> is<code> true</code>, if so, execute <code>Code Block 1</code>, otherwise execute <code>Code Block 2</code>. <code>else {...}</code> may be omitted if no action is required if <code>conditional_expression</code> is <code>false</code>.</p>
<p>It should be noted that by default, statement ends with a line break, so the <code>else</code> statement needs to be on the same line as the <code>}</code> of the <code>if</code> code block. If <code>else</code> starts a new line, a compilation error will occur.</p>
<p>The following is an example of multiple conditional statement:</p>
<pre><code class="language-wa">func Compare(x, y: int) =&gt; int {
    if x &lt; y {
        return 1
    } else if x &gt; y {
        return -1
    } else {
        return 0
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><em>The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: <a href="https://github.com/wa-lang/man/tree/master/en">https://github.com/wa-lang/man/tree/master/en</a></em></p>
<h2 id="45-for-statement"><a class="header" href="#45-for-statement">4.5. for statement</a></h2>
<p>There are three basic forms of loop statements:</p>
<pre><code class="language-wa">     for { code block }
     for ConditionalExpression { code block }
     for InitialStatement; ConditionalExpression; LoopOperationStatement { code block }
</code></pre>
<p>Among them, <code>for {code block}</code> will keep looping until the statements in the code block use the <code>break</code> keyword to exit the loop. Using the <code>continue</code> keyword will skip subsequent statements and execute the next loop, for example:</p>
<pre><code class="language-wa">    i: int
    for {
        i++
        if i == 2 {
            continue
        }
        println(i)
        if i == 3 {
            break
        }
    }
</code></pre>
<p>The above code will output:</p>
<pre><code>1
3
</code></pre>
<p><code>for ConditionalExpression {code block}</code>, before each time the loop executes <code>code block</code>, it will judge whether <code>ConditionalExpression</code> is <code>true</code>, if so, execute the code block, otherwise exit the loop. Statements within a code block can also use <code>break</code> and <code>continue</code> to exit the loop or skip subsequent statements to execute the next loop:</p>
<pre><code class="language-wa">     i: int
     for i &lt; 3 {
         println(i)
         i++
     }
</code></pre>
<p><code>for InitialStatement; ConditionalExpression; LoopOperationStatement {code block}</code>, it first executes the <code>InitialStatement</code> once, and then checks whether the <code>ConditionalExpression</code> is <code>true</code> before each execution of the <code>code block</code>, and executes it if it is code block, otherwise exit the loop; after each code block is executed, a <code>LoopOperationStatement</code> will be executed. Using the <code>break</code> keyword in a code block will exit the loop directly, and using the <code>continue</code> keyword will skip subsequent statements and execute the next loop (at this time the <code>LoopOperationStatement</code> will still be executed), for example:</p>
<pre><code class="language-wa">    for i := 0; i &lt; 100; i++ {
        if i == 1 {
            continue
        }
        println(i)
        if i == 2 {
            break
        }
    }
</code></pre>
<p>The above code will output:</p>
<pre><code>0
2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><em>The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: <a href="https://github.com/wa-lang/man/tree/master/en">https://github.com/wa-lang/man/tree/master/en</a></em></p>
<h2 id="46-switch-statements"><a class="header" href="#46-switch-statements">4.6. switch statements</a></h2>
<p>swtich statements are often used to replace multiple conditional statements. The general form is:</p>
<pre><code class="language-wa">     switch InitialStatement, ConditionalExpression {
     case expression1:
         code block 1

     case expression2:
         code block 2

     default:
         default code block
     }
</code></pre>
<p>The switch statement will first execute the optional <code>InitialStatement</code> (the <code>InitialStatement,</code> can be omitted, which means there is no initial action), and then judge from top to bottom whether the value of the <code>ConditionalExpression</code> equals with a certain <code>branch expression</code> if equal, the <code>code block</code> of the corresponding branch will be executed; if all branch conditions are not met, the optional <code>default code block</code> will be executed (omitting the <code>default</code> branch means there is no default code block). For example:</p>
<pre><code class="language-wa">func f(x: int) {
    switch x {
    case 0:
        println(&quot;x 为 0&quot;)

    case 1:
        println(&quot;x 为 1&quot;)

    default:
        println(&quot;x ==&quot;, x)
    }
}
</code></pre>
<p>Note that switch statements in Wa-lang languages ​​jump out by default: after entering a certain branch and executing the corresponding code block, the branch statement will jump out directly (that is, implicit <code>break</code>), which is opposite to the default behavior of C language.</p>
<p>Another special use of branch statements for type assertions will be described in Section 7.1.</p>
<div style="break-before: page; page-break-before: always;"></div><p><em>The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: <a href="https://github.com/wa-lang/man/tree/master/en">https://github.com/wa-lang/man/tree/master/en</a></em></p>
<h1 id="5-composite-types"><a class="header" href="#5-composite-types">5. Composite types</a></h1>
<p>Composite types are built-in complex types.</p>
<div style="break-before: page; page-break-before: always;"></div><p><em>The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: <a href="https://github.com/wa-lang/man/tree/master/en">https://github.com/wa-lang/man/tree/master/en</a></em></p>
<h1 id="6-custom-types"><a class="header" href="#6-custom-types">6. Custom types</a></h1>
<p>Custom types include structures and interfaces generated around structure methods.</p>
<div style="break-before: page; page-break-before: always;"></div><p><em>The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: <a href="https://github.com/wa-lang/man/tree/master/en">https://github.com/wa-lang/man/tree/master/en</a></em></p>
<h2 id="61-structure"><a class="header" href="#61-structure">6.1. Structure</a></h2>
<p>The general form of structure declaration in Wa-lang is:</p>
<pre><code class="language-wa">type StructName struct {
    Member list
}
</code></pre>
<p>The <code>member list</code> part is consistent with the variable declaration format, such as the following example:</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

type Info struct {
    name: string
    age:  i32
}

func PrintInfo(i: Info) {
    println(&quot;Name:&quot;, i.name, &quot;, Age:&quot;, i.age)
}

func main {
    i: Info
    i.name = &quot;张三&quot;
    i.age = 35
    PrintInfo(i) // Name: 张三 ，Age: 35
}
</code></pre>
<p>Like many languages, Wa-lang use the selection operator <code>.</code> to access members of a structure value. In addition, it is important to note that the selection operator <code>.</code> can also be used to access members of a structure reference, for example:</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

type Info struct {
    name: string
    age:  i32
}

func GetInfo() =&gt; *Info {
    i: Info
    i.name = &quot;李四&quot;
    i.age = 42
    return &amp;i
}

func main {
    j := GetInfo() // The type of j is a reference, *Info
    println(j.name, j.age) // 李四 42
}
</code></pre>
<p>It can be seen that whether it is a value or a reference, the way to access its members is the same, which is different from C language (C language uses <code>-&gt;</code> to access members of structure pointers).</p>
<p>The type of the structure members cannot be the structure itself, because this will cause infinite nesting; in fact, any structure that will cause infinite nesting is illegal, such as two structures containing each other. However, it is legal for a structure to contain references of this type (because the essence of a reference is a pointer). This usage is often used to create linked list structures, such as:</p>
<pre><code class="language-wa">type Node struct {
    data: i32
    next: *Node
}
</code></pre>
<p>Examples of structure literals are as follows:</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

type Info struct {
    name: string
    age:  i32
}

func main {
    i := Info{name: &quot;王五&quot;}
    println(j.name, j.age) // 王五 0
}
</code></pre>
<p>When declaring a structure literal, <code>{}</code> contains a list of member literals, and unlisted members have a value of 0.</p>
<p>If all member variables in the structure are comparable (that is, the <code>==</code> operation can be performed between variables of the member type), then the variables of the structure are also comparable. Among the data types introduced so far, slices are incomparable types, so structures that directly or indirectly contain slices are not comparable. Similar to other types of declarations, structures can be declared in any file within the module, and there is no need to &quot;declare before using&quot;.</p>
<div style="break-before: page; page-break-before: always;"></div><p><em>The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: <a href="https://github.com/wa-lang/man/tree/master/en">https://github.com/wa-lang/man/tree/master/en</a></em></p>
<h2 id="62-method"><a class="header" href="#62-method">6.2. Method</a></h2>
<p>In addition to encapsulating member data, the biggest role of structures is that they can have methods. In Wa-lang, <strong>method</strong> is a special type of function that is attached to a specific type, see the following example:</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

type Info struct {
    name: string
    age:  i32
}

// method declaration：
func Info.Print {
    println(&quot;Name:&quot;, this.name, &quot;, Age:&quot;, this.age)
}

func main {
    i := Info{name: &quot;Tom&quot;, age: 35}
    i.Print() // Name: Tom , Age: 35
}
</code></pre>
<p>The general form of method declaration is as follows:</p>
<pre><code class="language-wa">func TypeName.MethodName(parameter list) =&gt; (Return value list) {method function body}
</code></pre>
<p>The difference between method declaration and ordinary global function declaration is that <code>TypeName.</code> is added to the function name. Inside the method body, <code>this</code> is a reference to the type to which the method belongs, and its members can be read and written through <code>this.</code>.</p>
<p>If we only look at the syntax that has been introduced so far, methods and global functions can accomplish the same task. For example, the above example is almost equivalent to the following code:</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

type Info struct {
    name: string
    age:  i32
}

func Print(this: *Info) {
    println(&quot;Name:&quot;, this.name, &quot;, Age:&quot;, this.age)
}

func main {
    i := Info{name: &quot;Tom&quot;, age: 35}
    Print(&amp;i) // Name: Tom , Age: 35
}
</code></pre>
<p>As shown in the above example, if the first parameter of the global function is set to a reference of a custom type, its role is almost the same as that of the method. In fact, in Wa-lang, from a runtime perspective, the method is a function whose first parameter is a reference to a custom type. So why bother introducing this concept? There are two reasons:</p>
<ol>
<li>Methods help aggregate the functionality of an object;</li>
<li>The concept of <code>interface</code> is directly dependent on methods - the set of methods of a type determines the interface it implements, which is introduced in Chapter 7.</li>
</ol>
<blockquote>
<p>It is important to note that according to the concave language syntax, the method declared using <code>func T.xxx()...</code> does not belong to type <code>T</code>, but to type <code>*T</code>; That is to say, the named type itself cannot have methods, and only the reference of the named type can have methods.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p><em>The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: <a href="https://github.com/wa-lang/man/tree/master/en">https://github.com/wa-lang/man/tree/master/en</a></em></p>
<h2 id="63-method-values"><a class="header" href="#63-method-values">6.3. Method values</a></h2>
<p>Since methods are also functions, you can use them following the pattern in Section 4.2, for example:</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

type Vertex struct{
    x, y: i32
}

func Vertex.Scale(s: i32) {
    this.x *= s
    this.y *= s
}

func Vertex.Sub(s: i32) {
    this.x -= s
    this.y -= s
}

func Vertex.Print {
    println(&quot;x:&quot;, this.x, &quot;y:&quot;, this.y)
}

func FnOp(s: i32) {
    println(&quot;FnOp, s:&quot;, s)
}

func main {
    v := Vertex{x: 100, y:200}
    op : func(s: i32)

    op = FnOp // op此时是函数值FnOp
    op(13) // FnOp, s: 13

    op = v.Scale // op此时是方法值v.Scale
    op(2)
    v.Print() // x: 200 y: 400

    op = v.Sub // op此时是方法值v.Sub
    op(50)
    v.Print() // x: 150 y: 350
}
</code></pre>
<p><code>v.Scale</code> and <code>v.Sub</code> are methods of the structure variable <code>v</code>. When they are used as values, they are called <strong>method values</strong>. For example, in the above example, they are assigned to <code>op</code>. The method value can be called like an ordinary function value, and the call can affect the reference associated with the method (just like calling the original method directly). It can be seen that the method value captures the original object reference and is <code>stateful</code>. At this point, method values are similar to closures.</p>
<p>From the above example, we can also know that function value variables (such as <code>op</code> in the example) can store both function values and method values. For the caller, there is no difference between the two.</p>
<div style="break-before: page; page-break-before: always;"></div><p><em>The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: <a href="https://github.com/wa-lang/man/tree/master/en">https://github.com/wa-lang/man/tree/master/en</a></em></p>
<h2 id="64-embedded-structure"><a class="header" href="#64-embedded-structure">6.4. Embedded structure</a></h2>
<p>When declaring a structure type, if the type of a member is a structure but the name of it is omitted, this usage is called <strong>embedded structure</strong>. For example, in the following code, the structure <code>Sc</code> is embedded The <code>Sp</code> member:</p>
<pre><code class="language-wa">type Sp struct {
    x: i32
}

type Sc struct {
    Sp // embedded structure
    y: i32
}
</code></pre>
<p>The member name of the embedded structure is its type name, and we can still use the selector <code>.</code> to access it, such as the following printing code:</p>
<pre><code class="language-wa">    v: Sc
    println(v.Sp.x)
</code></pre>
<p>In this example, you can even omit the <code>.Sp</code> part. For example, the above code is equivalent to the following code:</p>
<pre><code class="language-wa">    v: Sc
    println(v.x)
</code></pre>
<p>In this usage, the structure <code>Sp</code> appears to be embedded in the structure <code>Sc</code>, which is where the name <strong>embedded structure</strong> comes from. However, if the structure contains a member with the same name as the embedded structure, it cannot be omitted when accessing the member with the same name of the embedded structure, for example:</p>
<pre><code>// 版权 @2023 凹语言 作者。保留所有权利。

type Sp struct {
    x: i32
}

type Sc2 strct {
    Sp
    x: f32
}

func main(){
    v: Sc2
    println(v.x)    // Print Sc2.x, its type is f32
    println(v.Sp.x) // Print Sc2.Sp.x, its type is i32
}
</code></pre>
<p>In addition to being able to reuse the data layout of a type, another important function of an embedded structure is that it can reuse type methods. The structure will automatically have the methods of the embedded type, for example:</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

type Sp struct {
    x: i32
}

func Sp.Show {
    println(this.x)
}

type Sc struct {
    Sp
    y: i32
}

func main {
    v := Sc{Sp:Sp{x: 42}, y: 13}
    v.Show() // 42
}
</code></pre>
<blockquote>
<p>When declaring an embedded structure literal, the name of the embedded structure cannot be omitted, such as <code>Sc{Sp:Sp{x: 42}, y: 13}</code> in the above example. If it is omitted like <code>{x: 42, y : 13}</code>, it will be considered illegal.</p>
</blockquote>
<p>After <code>Sp</code> is embedded in <code>Sc</code>, Sc obtains the method of Sp, so that the variable <code>v</code> of type <code>Sc</code> can perform the <code>Show</code> operation; in this example, <code>v.Show()</code> is equivalent to<code> v.Sp.Show()</code> . If the structure has a method with the same name as the embedded structure, the processing method is similar to the member with the same name, for example:</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

type Sp struct {
    x: i32
}

func Sp.Show {
    println(this.x)
}

type Sc struct {
    Sp
    x: f32
}

func Sc.Show {
    println(this.x)    
}

func main {
    v := Sc{Sp:Sp{x: 42}, x: 13.14}
    v.Show()    // 13.14
    v.Sp.Show() // 42
}
</code></pre>
<p>In order to achieve object reuse, Wa-lang does not adopt inheritance (which is different from C++), but uses combination. The embedded structure is a concrete manifestation of <strong>combination</strong>. The embedded structure reuses the memory layout and method set of the embedded type. Together with the interface (to be introduced in Chapter 7), it constitutes Wa-lang's foundation of abstraction and reusing of objects.</p>
<div style="break-before: page; page-break-before: always;"></div><p><em>The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: <a href="https://github.com/wa-lang/man/tree/master/en">https://github.com/wa-lang/man/tree/master/en</a></em></p>
<h2 id="65-anonymous-structure"><a class="header" href="#65-anonymous-structure">6.5. Anonymous structure</a></h2>
<p>In the previous sections of this chapter, the structures we used were declared in the following form:</p>
<pre><code class="language-wa">type StructName struct {
    Member list
}
</code></pre>
<p>In fact, the inner meaning of this grammar is:</p>
<ol>
<li>The part of <code>struct {...}</code> defines a structure;</li>
<li>The <code>type StructName</code> part gives a name to the structure just defined.</li>
</ol>
<p>So in Wa-lang, is it possible to directly create a structure variable by declaring a structure literal without naming the structure? It is indeed possible. This usage is called <strong>anonymous structure</strong>, for example:.</p>
<pre><code class="language-wa">// 版权 @2021 凹语言 作者。保留所有权利。

//Global anonymous structure variable：
global G: struct{
    name: string
    age: i32
}

func main {
    G.name = &quot;张三&quot;
    G.age = 88
    println(G.name, &quot; &quot;, G.age)  // 张三 88

    //local anonymous structure variable：
    k := struct {name: string; age: i32}{name: &quot;李四&quot;, age: 66}
    println(k.name, &quot; &quot;, k.age)  // 李四 66

    G = k
    println(G.name, &quot; &quot;, G.age)  // 李四 66
}
</code></pre>
<p>Since anonymous structures do not have type names, when declaring anonymous structure variables, you can only use <code>variable name: struct{...}</code> or its short-declaration form to directly specify the type (structure). In addition, the use of anonymous structures and their members is basically the same as ordinary named structures. Anonymous structures also follow the 0-value initialization rule. In their literal values, members with no initial value specified are all 0-value.</p>
<p>The most commonly used scenario for anonymous structures is global configuration variables. Many types of global configuration variables will only be used once when declaring the global variable. It is a bit cumbersome to define a separate type for a variable that only has one instance. In this case, an anonymous structure can be used instead (such as the global variable <code>G</code> in the above example).</p>
<p>The named type is located in the namespace of the module, but because the anonymous structure has no name, its definition is actually located in the global space. Therefore, if the memory layout of the two anonymous structure variables is exactly the same (that is, the number of members, corresponding member names, and corresponding members types are consistent), they will be considered to belong to the same type and can be assigned to each other (such as the global variable <code>G</code> and the local variable <code>k</code> in the above example). This feature still holds even if the two variables are located in different modules. ; This leads to another usage scenario of anonymous structures: passing parameters across modules.</p>
<p>Since an anonymous structure has no type name, according to the syntax rules, methods cannot be added to it.</p>
<div style="break-before: page; page-break-before: always;"></div><p><em>The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: <a href="https://github.com/wa-lang/man/tree/master/en">https://github.com/wa-lang/man/tree/master/en</a></em></p>
<h1 id="7-interface"><a class="header" href="#7-interface">7. Interface</a></h1>
<p>Interface is the soul of the abstract ability of the language. Wa-lang codes that do not use interfaces are pure realism, but with interfaces, abstraction can be achieved through duck-type object-oriented code. This chapter describes the basic usage of interfaces.</p>
<div style="break-before: page; page-break-before: always;"></div><p><em>The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: <a href="https://github.com/wa-lang/man/tree/master/en">https://github.com/wa-lang/man/tree/master/en</a></em></p>
<h2 id="71-null-interface---universal-wrapper"><a class="header" href="#71-null-interface---universal-wrapper">7.1. Null interface - universal wrapper</a></h2>
<p>In Wa-lang, the simplest interface is the null interface, namely <code>interface {}</code>. The method of declaring interface type variables is the same as other types. For example, the following code declares an null interface variable named <code>i</code>:</p>
<pre><code class="language-wa">    i: interface{}
</code></pre>
<p>Traditionally, we generally refer to <strong>interface type variables</strong> as <strong>interface values</strong>. The null interface has a very unique feature: <strong>Any type of value can be assigned to the null interface value</strong>. For example, the following operations are all legal:</p>
<pre><code class="language-wa">    iface: interface{}

    iface = 777         // Assigning untyped integer to null interface
    iface = 13.14       // Assigning an untyped floating point number to an null interface
    iface = &quot;你好，空接口&quot; // Assign string to null interface

    i: i64 = 58372665865
    iface = i // Assign 64-bit integer to null interface

    // Assign anonymous structure value to null interface：
    iface = struct{name: string; age: i32}{name: &quot;凹语言&quot;, age: 1}
</code></pre>
<p>This assignment behavior performs a value copy operation, which is equivalent to copying a copy of the original data in the interface value. This copy is called the <strong>concrete value</strong> of the interface value, and the type of the concrete value is called <strong>concrete type</strong>.</p>
<p>So how to determine the concrete type of an assigned interface value? How to read concrete value? This requires the use of <strong>type assertion</strong> syntax, whose general form is:</p>
<pre><code class="language-wa">    v, ok = iface.(Type) // Assert whether the concrete type of iface is Type
</code></pre>
<p>Among them, <code>v</code> is a value of type <code>Type</code>, and <code>ok</code> is a value of type <code>bool</code>. After the statement is executed, if <code>ok</code> is <code>true</code>, it means that the concrete type of the interface value <code>iface</code> is indeed<code> Type</code>, and its concrete value will be assigned to <code>v</code>; otherwise it indicates that the concrete type of <code>iface</code> is not <code>Type</code>. A example is as follows:</p>
<pre><code class="language-wa">// 版权 @2021 凹语言 作者。保留所有权利。

type T1 struct {
    a: i32
}

func main {
    ival: i32 = 777
    printConcrete(ival)       // i32: 777
    printConcrete(&quot;你好凹语言&quot;) // string: 你好凹语言

    v1 := T1{a: 42}
    printConcrete(v1) // T1, T1.a: 42

    printConcrete(13.14) // unknown type
}

func printConcrete(iface: interface{}) {
    ok: bool
    i: i32
    s: string
    t: T1

    i, ok = iface.(i32)
    if ok {
        println(&quot;i32:&quot;, i)
        return
    }

    s, ok = iface.(string)
    if ok {
        println(&quot;string:&quot;, s)
        return
    }

    t, ok = iface.(T1)
    if ok {
        println(&quot;T1, T1.a:&quot;, t.a)
        return
    }

    println(&quot;unknown type&quot;)
}
</code></pre>
<p>In the function <code>printConcrete</code>, through interface type assertion, the concrete type of the incoming null interface value can be dynamically determined and its concrete value can be obtained. Since there is no floating point assertion within the function, &quot;unknown type&quot; is output when a floating point number is entered.</p>
<p>Note that the parameter type of the function <code>printConcrete</code> is an null interface (<code>interface{}</code>). When calling it in the <code>main</code> function, an implicit conversion (copy) is actually performed. For example, the statement <code>printConcrete(ival)</code> actually Equivalent to:</p>
<pre><code class="language-wa">    iface: interface{} = ival
    printConcrete(iface)
</code></pre>
<blockquote>
<p>Wa-lang do not allow implicit type conversion in most cases, but interfaces are an exception. When the function parameter type is an interface, if the actual parameter filled in by the caller is a concrete type, the compiler will automatically perform assignment conversion.</p>
</blockquote>
<p>If there are multiple possibilities for the concrete type of the interface value, then using multiple type assertions plus conditional judgment will undoubtedly be cumbersome. In this scenario, you can use branch type assertions in the format of <code>switch...case...</code>. For example, the above <code>printConcrete</code> function can be rewritten as:</p>
<pre><code class="language-wa">func printConcrete(iface: interface{}) {
    //branch type assertion
    switch v := iface.(type) {
    case i32:
        println(&quot;i32:&quot;, v)  // v is the concrete value of iface. Under this branch, its type is i32, the same below.

    case string:
        println(&quot;string:&quot;, v)

    case T1:
        println(&quot;T1, T1.a:&quot;, v.a)

    default:
        println(&quot;unknown type&quot;)
    }
}
</code></pre>
<p>Among them, <code>iface.(type)</code> is a fixed writing method, and each subsequent <code>case</code> branch indicates that the concrete type satisfies the branch condition.</p>
<p>Any type of value can be assigned to the null interface. It actually plays the role of a universal wrapper in Wa-lang and is often used to transfer values whose types change dynamically between functions.</p>
<blockquote>
<p>In this article, &quot;<strong>null interface</strong>&quot; refers to <code>interface{}</code>, which is an interface type whose method set is empty. &quot;<strong>non-null interface</strong>&quot; in the next section refers to an interface type whose method set is not empty; When we want to describe an interface value with a value of 0, we will use &quot;<strong>0 value interface</strong>&quot;, or &quot;<strong>nil interface</strong>&quot;, please pay attention to the distinction.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p><em>The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: <a href="https://github.com/wa-lang/man/tree/master/en">https://github.com/wa-lang/man/tree/master/en</a></em></p>
<h2 id="72-non-null-interface"><a class="header" href="#72-non-null-interface">7.2. Non-null interface</a></h2>
<p>An interface is a collection of methods. The general form of an interface declaration is as follows:</p>
<pre><code class="language-wa">type InterfaceName interface {
    MethodSet
}
</code></pre>
<p>The attributes of methods in the <code>MethodSet</code> include the method name and the function signature of the method. For example, we define an interface as follows:</p>
<pre><code class="language-wa">type Stringer interface {
    String() =&gt; string
}
</code></pre>
<p>The interface is named <code>Stringer</code> and contains a method named <code>String</code>, which has no input parameters and returns a string.</p>
<p>If a method set of a concrete type <code>T</code> is a superset of the method set MethodSet_i of a certain interface <code>I</code>, then we say: <strong>Type <code>T</code> satisfies the interface <code>I</code></strong>. In other words, let the method set of type <code>T</code> be <code>St</code>, the method set of interface <code>I</code> be <code>Si</code>, and the necessary and sufficient condition for type <code>T</code> to satisfy interface <code>I</code> is: any <code>m ∈ Si </code>, there exists <code>m' ∈ St</code>, such that <code>m</code> and <code>m'</code> have the same name and the same function signature.</p>
<p><strong>If the type <code>T</code> satisfies the interface <code>I</code>, then the value of type <code>T</code> will be assigned to the interface value of type <code>I</code></strong>. When performing the assignment operation, the value of type <code>T</code> will be Copy to the interface value; this is also the reason why the empty interface is the universal wrapper in the previous section, because according to the above definition, the method set of <code>interface{}</code> is empty, and any type can satisfy it.</p>
<p>Interface methods can be called, and the call will dynamically switch to the method with the same name of the concrete value contained in the interface value (if the concrete value contained in the interface value is nil, then the call will trigger a runtime exception). Non-null interface is an important abstraction method in Wa-lang. Different types of objects can satisfy the same interface, so that callers can use different types of objects in a unified way through the interface. Therefore, the essence of the interface is a set of method conventions, and the check of this convention (whether the concrete type satisfies a certain interface), which is completed at compile time. Here is a example:</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

type Printer interface {
    Print()
}

type T1 struct {
    i: i32
}

func T1.Print {
    println(&quot;This is T1, this.i:&quot;, this.i)
}

type T2 struct {
    s: string
}

func T2.Print {
    println(&quot;This is T2, this.s:&quot;, this.s)
}

func PrintObj(p: Printer) {
    p.Print()
}

func main {
    p: Printer

    v1: T1
    v1.i = 42
    p = &amp;v1
    PrintObj(p) // This is T1, this.i: 42

    v2: T2
    v2.s = &quot;你好&quot;
    p = &amp;v2
    PrintObj(p) // This is T2, this.s: 你好
}
</code></pre>
<p>It can be seen that when different objects are encapsulated in the same interface value <code>p</code>, and it is used in the same way, its behavior will also change with different object types.</p>
<p>Since the named type itself cannot have methods, but only its reference can have methods (refer to Section 6.2), in the above example, <code>v1</code> cannot be assigned to <code>p</code>, but only its reference <code>&amp;v1</code> can. If you try to assign <code>v1</code> to <code>p</code>, a compilation error will occur.</p>
<div style="break-before: page; page-break-before: always;"></div><p><em>The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: <a href="https://github.com/wa-lang/man/tree/master/en">https://github.com/wa-lang/man/tree/master/en</a></em></p>
<h2 id="73-summary-of-type-assertions"><a class="header" href="#73-summary-of-type-assertions">7.3. Summary of type assertions</a></h2>
<p>Section 7.1 introduces how to obtain the specific value contained in an interface value of type <code>interface{}</code> through type assertion. This usage still holds for non-null interface values, for example:</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

type Printer interface {
    Print()
}

type T1 struct {
    i: i32
}

func T1.Print { println(&quot;This is T1, this.i:&quot;, this.i) }

type T2 struct {
    s: string
}

func T2.Print { println(&quot;This is T2, this.s:&quot;, this.s) }

func doConcrete(p: Printer) {
    switch v := p.(type) {
    case *T1:
        v.Print()

    case *T2:
        v.Print()
    }
}

func main {
    v1 := T1{i: 42}
    doConcrete(&amp;v1) // This is T1, this.i: 42

    v2 := T2{s: &quot;hello&quot;}
    doConcrete(&amp;v2) // This is T2, this.s: hello
}
</code></pre>
<p>Note that <code>v.Print()</code> in function <code>doConcrete</code> is a direct call, not an interface call, because in the <code>case *T1</code> branch, the type of <code>v</code> is <code>*T1</code>. In addition, non-null interface values can also perform concrete type assertions in the form of <code>v, ok = iface.(Type)</code>, which is consistent with the application method of null interface values in Section 7.1.</p>
<p>In fact, the usage of type assertions goes beyond this. In some cases, a concrete type <code>*T</code> may satisfy multiple interfaces <code>I1</code> and <code>I2</code> at the same time. Then when the interface value of an <code>I1</code> contains concrete value type of <code>*T</code>, you can directly obtain an interface value of type <code>I2</code> through type assertion on the interface value, for example:</p>
<pre><code class="language-wa">// 版权 @2023 凹语言 作者。保留所有权利。

type I1 interface {
    f1()
}

type I2 interface {
    f2()
}

type T struct {
    i: i32
}

func T.f1 { println(&quot;T.f1(), T.i:&quot;, this.i) }

func T.f2 { println(&quot;T.f2(), T.i:&quot;, this.i) }

func main {
    v1 := T{i: 42}

    i1: I1 = &amp;v1
    i1.f1() // T.f1(), T.i: 42

    i2, ok := i1.(I2) // 断言为另一个接口
    if ok {
        i2.f2() // T.f2(), T.i: 42
    }
}
</code></pre>
<p>This usage is generally seen in getting a non-null interface from an <code>interface{}</code> value.</p>
<p>In addition to type assertions of the form <code>v, ok = iface.(Type)</code>, there is another pattern of type assertions:</p>
<pre><code class="language-wa">    v = iface.(Type)
</code></pre>
<p>This mode omits the <code>ok</code> flag indicating whether the operation was successful and only returns the value of the asserted type. If a type assertion fails, a runtime exception will be triggered, and it is recommended to only use this pattern if you are absolutely certain that the assertion will not fail.</p>
<div style="break-before: page; page-break-before: always;"></div><p><em>The content on this page is written in Chinese, and then traslated into English by machine. More accurate traslations are welcome at: <a href="https://github.com/wa-lang/man/tree/master/en">https://github.com/wa-lang/man/tree/master/en</a></em></p>
<h2 id="74-other-features-of-interface"><a class="header" href="#74-other-features-of-interface">7.4. Other features of interface</a></h2>
<p>When declaring an interface, the interface's method set can contain another interface, for example:</p>
<pre><code class="language-wa">type I1 interface {
    f1()
}

type I2 interface {
    I1
    f2()
}
</code></pre>
<p>Using this form, the compiler will copy the methods of interface <code>I1</code> to the method set of <code>I2</code>, which is equivalent to directly adding <code>f1()</code> to the method set of <code>I2</code>.</p>
<p>If the method set of interface <code>I2</code> is a true superset of the method set of interface <code>I1</code>, we say that &quot;compared with I1, I2 is a small interface&quot;. This statement seems a bit counter-intuitive, but its internal logic is: the interface is For method contracts, since there are more methods in <code>I2</code>, the set of types that satisfy <code>I2</code> must be a subset of the set of types that satisfy <code>I1</code>. From this perspective, the empty interface (<code>interface{}</code>) is the largest interface. The more methods contained in a non-empty interface, the smaller the interface tends to be.</p>
<p>We can also declare anonymous interface values. Anonymous interfaces are similar to anonymous structures in all aspects. They are located in the global namespace (can be used across modules).</p>
<p>Interface calls are slightly slower than direct calls from concrete types, so there is no need to create an interface for behavior (or set of methods) that only one type satisfies.</p>
<p>Interface values are comparable. Two non-nil interface values <code>i1</code> and <code>i2</code> are equal only if the following conditions are met (that is, the expression <code>i1==i2</code> is <code>true</code>):</p>
<ul>
<li>The concrete type of <code>i1</code> is the same as the concrete type of <code>i2</code>, and the types are comparable</li>
<li>The concrete value of <code>i1</code> is equal to the concrete value of <code>i2</code></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
